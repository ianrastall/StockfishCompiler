
==== BEGIN FILE: StockfishCompiler.csproj (D:\GitHub\StockfishCompiler\StockfishCompiler.csproj) ====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
    <SelfContained>false</SelfContained>
    <PublishSingleFile>false</PublishSingleFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.3.2" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.0" />
    <PackageReference Include="Serilog" Version="4.2.0" />
    <PackageReference Include="Serilog.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    <PackageReference Include="System.Reactive" Version="6.0.0" />
  </ItemGroup>

</Project>

==== END FILE: StockfishCompiler.csproj ====

==== BEGIN FILE: App.xaml (D:\GitHub\StockfishCompiler\App.xaml) ====
<Application x:Class="StockfishCompiler.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             DispatcherUnhandledException="Application_DispatcherUnhandledException">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Resources/DarkTheme.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>

==== END FILE: App.xaml ====

==== BEGIN FILE: App.xaml.cs (D:\GitHub\StockfishCompiler\App.xaml.cs) ====
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Serilog;
using System.IO;
using System.Net.Http;
using System.Windows;
using StockfishCompiler.Services;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        public static ServiceProvider Services { get; private set; } = null!;

        protected override void OnStartup(StartupEventArgs e)
        {
            // Set up logging first
            var logPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "StockfishCompiler",
                "logs",
                $"app-{DateTime.Now:yyyy-MM-dd}.log"
            );

            Directory.CreateDirectory(Path.GetDirectoryName(logPath)!);

            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            Log.Information("Application starting...");
            Log.Information("Log file: {LogPath}", logPath);

            try
            {
                base.OnStartup(e);

                var services = new ServiceCollection();

                // Logging
                services.AddLogging(builder =>
                {
                    builder.AddSerilog();
                    builder.SetMinimumLevel(LogLevel.Debug);
                });

                // Basic HttpClient registration (no factory extensions available)
                services.AddSingleton<HttpClient>();
                services.AddSingleton<IStockfishDownloader, StockfishDownloader>();

                // Services
                services.AddSingleton<ICompilerService, CompilerService>();
                services.AddSingleton<ICompilerInstallerService, CompilerInstallerService>();
                services.AddSingleton<IArchitectureDetector, ArchitectureDetector>();
                services.AddSingleton<IBuildService, BuildService>();
                services.AddSingleton<IUserSettingsService, UserSettingsService>();

                // ViewModels
                services.AddSingleton<MainViewModel>();
                services.AddSingleton<BuildViewModel>();

                Services = services.BuildServiceProvider();

                Log.Information("Services configured successfully");

                var window = new MainWindow
                {
                    DataContext = Services.GetRequiredService<MainViewModel>()
                };

                Log.Information("MainWindow created, showing...");
                window.Show();
                Log.Information("Application startup complete");
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, "Application failed to start");
                MessageBox.Show(
                    $"Application failed to start:\n\n{ex.Message}\n\nLog file: {logPath}",
                    "Startup Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error
                );
                Log.CloseAndFlush();
                Shutdown(1);
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Log.Information("Application exiting with code {ExitCode}", e.ApplicationExitCode);
            Log.CloseAndFlush();
            base.OnExit(e);
        }

        private void Application_DispatcherUnhandledException(object sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs e)
        {
            Log.Error(e.Exception, "Unhandled exception occurred");
            MessageBox.Show(
                $"An unexpected error occurred:\n\n{e.Exception.Message}\n\nCheck logs for details.",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error
            );
            e.Handled = true;
        }
    }
}

==== END FILE: App.xaml.cs ====

==== BEGIN FILE: MainWindow.xaml (D:\GitHub\StockfishCompiler\MainWindow.xaml) ====
<Window x:Class="StockfishCompiler.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:views="clr-namespace:StockfishCompiler.Views"
        mc:Ignorable="d"
        Title="Stockfish Compiler" Height="750" Width="950" WindowStartupLocation="CenterScreen">

    <Grid Background="{StaticResource SecondaryBrush}">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <Border Grid.Row="0" Background="{StaticResource PrimaryBrush}" Padding="20,15" BorderBrush="{StaticResource BorderBrush}" BorderThickness="0,0,0,1">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Stockfish Compiler" FontSize="24" FontWeight="Bold" Foreground="{StaticResource TextPrimaryBrush}"/>
                <TextBlock Text="v1.0" Margin="10,5,0,0" Foreground="{StaticResource TextSecondaryBrush}" VerticalAlignment="Bottom"/>
            </StackPanel>
        </Border>

        <TabControl Grid.Row="1" Style="{StaticResource DarkTabControl}">
            <TabItem Header="Compiler Setup" Style="{StaticResource DarkTabItem}">
                <views:CompilerSelectionView/>
            </TabItem>
            <TabItem Header="Build Configuration" Style="{StaticResource DarkTabItem}">
                <views:BuildConfigurationView/>
            </TabItem>
            <TabItem Header="Compilation" Style="{StaticResource DarkTabItem}">
                <views:BuildProgressView/>
            </TabItem>
        </TabControl>

        <StatusBar Grid.Row="2" Background="{StaticResource SecondaryBrush}">
            <StatusBarItem>
                <TextBlock Text="{Binding StatusMessage}"/>
            </StatusBarItem>
            <StatusBarItem HorizontalAlignment="Right">
                <TextBlock Text="{Binding SystemInfo}"/>
            </StatusBarItem>
        </StatusBar>

        <Border Grid.Row="3" Background="{StaticResource PrimaryBrush}" Padding="10,5" BorderBrush="{StaticResource BorderBrush}" BorderThickness="0,1,0,0">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <TextBlock Text="Logs:" Foreground="{StaticResource TextSecondaryBrush}" Margin="0,0,5,0" VerticalAlignment="Center"/>
                <Button Content="Open Log Folder" Click="OpenLogsFolder_Click" Style="{StaticResource DarkButton}" Padding="10,4" Margin="0"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>

==== END FILE: MainWindow.xaml ====

==== BEGIN FILE: MainWindow.xaml.cs (D:\GitHub\StockfishCompiler\MainWindow.xaml.cs) ====
using System.Diagnostics;
using System.IO;
using System.Windows;

namespace StockfishCompiler
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void OpenLogsFolder_Click(object sender, RoutedEventArgs e)
        {
            var logPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "StockfishCompiler",
                "logs"
            );

            if (Directory.Exists(logPath))
            {
                Process.Start("explorer.exe", logPath);
            }
            else
            {
                MessageBox.Show(
                    "No logs directory found yet. Logs will be created when the application runs.",
                    "Logs",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information
                );
            }
        }
    }
}
==== END FILE: MainWindow.xaml.cs ====

==== BEGIN FILE: AssemblyInfo.cs (D:\GitHub\StockfishCompiler\AssemblyInfo.cs) ====
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]

==== END FILE: AssemblyInfo.cs ====

==== BEGIN FILE: Views\BuildConfigurationView.xaml (D:\GitHub\StockfishCompiler\Views\BuildConfigurationView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.BuildConfigurationView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ScrollViewer>
        <StackPanel Margin="20">
            <GroupBox Header="Build Options" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <CheckBox Content="Download neural network (NNUE)" IsChecked="{Binding DownloadNetwork}" Style="{StaticResource DarkCheckBox}" Margin="0,5"/>
                    <CheckBox Content="Strip executable (reduce file size)" IsChecked="{Binding StripExecutable}" Style="{StaticResource DarkCheckBox}" Margin="0,5"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,10,0,5">
                        <TextBlock Text="Parallel jobs:" Style="{StaticResource LabelText}" VerticalAlignment="Center"/>
                        <TextBox Width="60" Text="{Binding ParallelJobs}" Style="{StaticResource DarkTextBox}"/>
                        <TextBlock Text="(CPU cores)" Style="{StaticResource InfoText}" Margin="10,0" VerticalAlignment="Center"/>
                    </StackPanel>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Output Directory" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBox Text="{Binding OutputDirectory}" Style="{StaticResource DarkTextBox}" Margin="0,5"/>
                    <TextBlock Text="The compiled Stockfish executable will be saved here." Style="{StaticResource DescriptionText}" Margin="0,5,0,0"/>
                </StackPanel>
            </GroupBox>
        </StackPanel>
    </ScrollViewer>
</UserControl>
==== END FILE: Views\BuildConfigurationView.xaml ====

==== BEGIN FILE: Views\BuildConfigurationView.xaml.cs (D:\GitHub\StockfishCompiler\Views\BuildConfigurationView.xaml.cs) ====
using System.Windows.Controls;

namespace StockfishCompiler.Views
{
    public partial class BuildConfigurationView : UserControl
    {
        public BuildConfigurationView()
        {
            InitializeComponent();
        }
    }
}

==== END FILE: Views\BuildConfigurationView.xaml.cs ====

==== BEGIN FILE: Views\BuildProgressView.xaml (D:\GitHub\StockfishCompiler\Views\BuildProgressView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.BuildProgressView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:helpers="clr-namespace:StockfishCompiler.Helpers">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <ProgressBar Grid.Row="0" Height="18" Value="{Binding BuildProgress}" Style="{StaticResource DarkProgressBar}" Margin="0,0,0,10"/>

        <TextBox Grid.Row="1"
                 Text="{Binding BuildOutput}"
                 Style="{StaticResource DarkTextBox}"
                 AcceptsReturn="True"
                 TextWrapping="Wrap"
                 IsReadOnly="True"
                 VerticalScrollBarVisibility="Auto"
                 Margin="0,0,0,10"
                 FontFamily="Consolas"
                 FontSize="11"
                 helpers:TextBoxHelper.AlwaysScrollToEnd="True"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right">
            <Button Content="Start Build" Command="{Binding StartBuildCommand}" Style="{StaticResource DarkButton}"/>
            <Button Content="Cancel" Command="{Binding CancelBuildCommand}" Style="{StaticResource DarkButton}"/>
        </StackPanel>
    </Grid>
</UserControl>

==== END FILE: Views\BuildProgressView.xaml ====

==== BEGIN FILE: Views\BuildProgressView.xaml.cs (D:\GitHub\StockfishCompiler\Views\BuildProgressView.xaml.cs) ====
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler.Views
{
    public partial class BuildProgressView : UserControl
    {
        public BuildProgressView()
        {
            InitializeComponent();
            // Safe runtime resolution; skip during design-time or before App.Services initialized
            if (App.Services != null)
            {
                var vm = App.Services.GetService<BuildViewModel>();
                if (vm != null)
                    DataContext = vm;
            }
        }
    }
}

==== END FILE: Views\BuildProgressView.xaml.cs ====

==== BEGIN FILE: Views\CompilerSelectionView.xaml (D:\GitHub\StockfishCompiler\Views\CompilerSelectionView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.CompilerSelectionView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ScrollViewer>
        <StackPanel Margin="20">
            <GroupBox Header="System Information" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="{Binding SystemInfo}" Style="{StaticResource InfoText}" Margin="0,5"/>
                    <StackPanel Orientation="Horizontal">
                        <Button Content="Detect Compilers" 
                                Command="{Binding DetectCompilersCommand}" 
                                Style="{StaticResource DarkButton}" 
                                HorizontalAlignment="Left"
                                IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                        <Button Content="Download &amp; Install MSYS2 (GCC)"
                                Click="InstallCompiler_Click"
                                Style="{StaticResource DarkButton}"
                                HorizontalAlignment="Left"
                                IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                    </StackPanel>
                    <TextBlock Text="If no compiler is found, use the installer to grab MSYS2 + GCC, then re-run detection."
                               Style="{StaticResource DescriptionText}"
                               Margin="0,5,0,0"/>
                    <TextBlock Text="Detecting compilers..." 
                               Style="{StaticResource InfoText}" 
                               Margin="10,5" 
                               Visibility="{Binding IsDetectingCompilers, Converter={StaticResource BoolToVisibilityConverter}}"/>
                    <TextBlock Text="{Binding DetectionDetails}"
                               Style="{StaticResource DescriptionText}"
                               Margin="0,5,0,0"
                               TextWrapping="Wrap"/>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Compiler Selection" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="Select a compiler from the dropdown:" 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,0,0,5"/>
                    
                    <ComboBox ItemsSource="{Binding AvailableCompilers}"
                              SelectedItem="{Binding SelectedCompiler}"
                              DisplayMemberPath="DisplayName"
                              Style="{StaticResource DarkComboBox}" 
                              Height="35" 
                              Margin="0,5"
                              IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,10,0,5" Visibility="{Binding SelectedCompiler, Converter={StaticResource NullToVisibilityConverter}}">
                        <TextBlock Text="Compiler Path:" Style="{StaticResource LabelText}"/>
                        <TextBlock Text="{Binding SelectedCompiler.Path}" Style="{StaticResource ValueText}"/>
                    </StackPanel>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,5" Visibility="{Binding SelectedCompiler, Converter={StaticResource NullToVisibilityConverter}}">
                        <TextBlock Text="Version:" Style="{StaticResource LabelText}"/>
                        <TextBlock Text="{Binding SelectedCompiler.Version}" Style="{StaticResource ValueText}"/>
                    </StackPanel>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Architecture Selection" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="CPU architecture determines optimal instruction sets for performance." 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,0,0,10"/>
                    
                    <Button Content="Detect Optimal Architecture" 
                            Command="{Binding DetectArchitectureCommand}" 
                            Style="{StaticResource DarkButton}" 
                            HorizontalAlignment="Left"/>
                    
                    <TextBlock Text="Detecting CPU features..." 
                               Style="{StaticResource InfoText}" 
                               Margin="10,5" 
                               Visibility="{Binding IsDetectingArchitecture, Converter={StaticResource BoolToVisibilityConverter}}"/>
                    
                    <ComboBox ItemsSource="{Binding AvailableArchitectures}"
                              SelectedItem="{Binding SelectedArchitecture}"
                              DisplayMemberPath="Name"
                              Style="{StaticResource DarkComboBox}" 
                              Height="35" 
                              Margin="0,10,0,5"
                              IsEnabled="{Binding IsDetectingArchitecture, Converter={StaticResource InverseBooleanConverter}}"/>
                    
                    <TextBlock Text="{Binding SelectedArchitecture.Description}" 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,5,0,0"
                               Visibility="{Binding SelectedArchitecture, Converter={StaticResource NullToVisibilityConverter}}"/>
                </StackPanel>
            </GroupBox>
        </StackPanel>
    </ScrollViewer>
</UserControl>

==== END FILE: Views\CompilerSelectionView.xaml ====

==== BEGIN FILE: Views\CompilerSelectionView.xaml.cs (D:\GitHub\StockfishCompiler\Views\CompilerSelectionView.xaml.cs) ====
using System.Windows;
using System.Windows.Controls;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler.Views
{
    public partial class CompilerSelectionView : UserControl
    {
        public CompilerSelectionView()
        {
            InitializeComponent();
        }

        private async void InstallCompiler_Click(object sender, RoutedEventArgs e)
        {
            var installerWindow = new CompilerInstallerWindow(App.Services)
            {
                Owner = Window.GetWindow(this)
            };

            var result = installerWindow.ShowDialog();
            if (result == true && installerWindow.CompilerInstalled && DataContext is MainViewModel vm)
            {
                vm.StatusMessage = "Re-running compiler detection after install...";
                await vm.DetectCompilersCommand.ExecuteAsync(null);
            }
        }
    }
}

==== END FILE: Views\CompilerSelectionView.xaml.cs ====

==== BEGIN FILE: Views\CompilerInstallerWindow.xaml (D:\GitHub\StockfishCompiler\Views\CompilerInstallerWindow.xaml) ====
<Window x:Class="StockfishCompiler.Views.CompilerInstallerWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Install C++ Compiler" 
        Height="400" 
        Width="600"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize">

    <Window.Resources>
        <Style TargetType="Window">
            <Setter Property="Background" Value="#1e1e1e"/>
        </Style>
    </Window.Resources>

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" 
                   Text="No C++ Compiler Found" 
                   FontSize="24" 
                   FontWeight="Bold" 
                   Foreground="White"
                   Margin="0,0,0,10"/>

        <TextBlock Grid.Row="1" 
                   TextWrapping="Wrap"
                   Foreground="#cccccc"
                   Margin="0,0,0,20">
            <Run Text="To compile Stockfish, you need a C++ compiler. "/>
            <Run Text="We can automatically install MSYS2 with GCC for you."/>
            <LineBreak/>
            <LineBreak/>
            <Run Text="This will:"/>
            <LineBreak/>
            <Run Text="- Download and install MSYS2 (~100 MB)"/>
            <LineBreak/>
            <Run Text="- Install the MinGW-w64 GCC compiler"/>
            <LineBreak/>
            <Run Text="- Configure everything automatically"/>
        </TextBlock>

        <ScrollViewer Grid.Row="2" 
                      VerticalScrollBarVisibility="Auto"
                      Margin="0,0,0,20">
            <TextBox x:Name="LogTextBox"
                     IsReadOnly="True"
                     Background="#2d2d30"
                     Foreground="#cccccc"
                     FontFamily="Consolas"
                     BorderThickness="1"
                     BorderBrush="#555555"
                     Padding="10"
                     TextWrapping="Wrap"/>
        </ScrollViewer>

        <Grid Grid.Row="3">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <ProgressBar x:Name="InstallProgress"
                         Grid.Column="0"
                         Height="25"
                         Margin="0,0,10,0"
                         Visibility="Collapsed"/>

            <Button x:Name="InstallButton"
                    Grid.Column="1"
                    Content="Install Compiler"
                    Width="120"
                    Height="30"
                    Margin="0,0,10,0"
                    Background="#007ACC"
                    Foreground="White"
                    Click="InstallButton_Click"/>

            <Button x:Name="CancelButton"
                    Grid.Column="2"
                    Content="Cancel"
                    Width="80"
                    Height="30"
                    Background="#555555"
                    Foreground="White"
                    Click="CancelButton_Click"/>
        </Grid>
    </Grid>
</Window>

==== END FILE: Views\CompilerInstallerWindow.xaml ====

==== BEGIN FILE: Views\CompilerInstallerWindow.xaml.cs (D:\GitHub\StockfishCompiler\Views\CompilerInstallerWindow.xaml.cs) ====
using System;
using System.Threading.Tasks;
using System.Windows;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.Services;

namespace StockfishCompiler.Views;

public partial class CompilerInstallerWindow : Window
{
    private readonly ICompilerInstallerService _installerService;
    private bool _isInstalling;

    public bool CompilerInstalled { get; private set; }
    public string? InstalledPath { get; private set; }

    public CompilerInstallerWindow(IServiceProvider serviceProvider)
    {
        InitializeComponent();
        _installerService = serviceProvider.GetRequiredService<ICompilerInstallerService>();
    }

    private async void InstallButton_Click(object sender, RoutedEventArgs e)
    {
        if (_isInstalling) return;

        _isInstalling = true;
        InstallButton.IsEnabled = false;
        InstallProgress.Visibility = Visibility.Visible;
        LogTextBox.Clear();

        var progress = new Progress<string>(message =>
        {
            Dispatcher.Invoke(() =>
            {
                LogTextBox.AppendText($"{DateTime.Now:HH:mm:ss} - {message}\n");
                LogTextBox.ScrollToEnd();
            });
        });

        try
        {
            var (success, installPath) = await Task.Run(() => 
                _installerService.InstallMSYS2Async(progress));

            if (success)
            {
                CompilerInstalled = true;
                InstalledPath = installPath;
                
                MessageBox.Show(
                    "Compiler installed successfully!\n\n" +
                    $"Location: {installPath}\n\n" +
                    "Click OK to continue with compiler detection.",
                    "Installation Complete",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);
                
                DialogResult = true;
            }
            else
            {
                MessageBox.Show(
                    "Compiler installation failed.\n\n" +
                    "Please check the log for details or install MSYS2 manually.",
                    "Installation Failed",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
        }
        catch (Exception ex)
        {
            MessageBox.Show(
                $"An error occurred during installation:\n\n{ex.Message}",
                "Installation Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }
        finally
        {
            _isInstalling = false;
            InstallButton.IsEnabled = true;
            InstallProgress.Visibility = Visibility.Collapsed;
        }
    }

    private void CancelButton_Click(object sender, RoutedEventArgs e)
    {
        if (_isInstalling)
        {
            var result = MessageBox.Show(
                "Installation is in progress. Are you sure you want to cancel?",
                "Cancel Installation",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);
            
            if (result != MessageBoxResult.Yes) return;
        }

        DialogResult = false;
    }
}
==== END FILE: Views\CompilerInstallerWindow.xaml.cs ====

==== BEGIN FILE: ViewModels\MainViewModel.cs (D:\GitHub\StockfishCompiler\ViewModels\MainViewModel.cs) ====
using System.Collections.ObjectModel;
using System.Runtime.InteropServices;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;
using StockfishCompiler.Services;
using StockfishCompiler.Helpers;

namespace StockfishCompiler.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly ICompilerService _compilerService;
    private readonly IArchitectureDetector _architectureDetector;
    private readonly ILogger<MainViewModel> _logger;
    private readonly IUserSettingsService _userSettingsService;
    private UserSettings _userSettings = new();
    private bool _isRestoringSettings;

    public MainViewModel(
        ICompilerService compilerService, 
        IArchitectureDetector architectureDetector, 
        ILogger<MainViewModel> logger,
        IUserSettingsService userSettingsService)
    {
        _compilerService = compilerService;
        _architectureDetector = architectureDetector;
        _logger = logger;
        _userSettingsService = userSettingsService;

        _logger.LogInformation("MainViewModel initializing");

        DetectCompilersCommand = new AsyncRelayCommand(DetectCompilersAsync);
        DetectArchitectureCommand = new AsyncRelayCommand(DetectOptimalArchitectureAsync, () => SelectedCompiler != null);

        LoadUserSettings();
        _ = LoadAvailableArchitectures();
        
        _logger.LogInformation("MainViewModel initialized");
    }

    [ObservableProperty]
    private ObservableCollection<CompilerInfo> availableCompilers = [];

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(DetectArchitectureCommand))]
    private CompilerInfo? selectedCompiler;

    [ObservableProperty]
    private ObservableCollection<ArchitectureInfo> availableArchitectures = [];

    [ObservableProperty]
    private ArchitectureInfo? selectedArchitecture;

    [ObservableProperty]
    private string statusMessage = "Ready";

    [ObservableProperty]
    private bool isDetectingCompilers;

    [ObservableProperty]
    private bool isDetectingArchitecture;

    [ObservableProperty]
    private string sourceVersion = "stable";

    [ObservableProperty]
    private bool downloadNetwork = true;

    [ObservableProperty]
    private bool stripExecutable = true;

    [ObservableProperty]
    private int parallelJobs = Environment.ProcessorCount;

    [ObservableProperty]
    private string outputDirectory = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

    [ObservableProperty]
    private string detectionDetails = string.Empty;

    public IAsyncRelayCommand DetectCompilersCommand { get; }
    public IAsyncRelayCommand DetectArchitectureCommand { get; }

    private async Task DetectCompilersAsync()
    {
        try
        {
            IsDetectingCompilers = true;
            DetectionDetails = string.Empty;
            _logger.LogInformation("Starting compiler detection");
            StatusMessage = "Detecting compilers...";
            
            var compilers = await _compilerService.DetectCompilersAsync();
            
            AvailableCompilers = new ObservableCollection<CompilerInfo>(compilers);
            if (compilers.Count > 0)
            {
                SelectedCompiler = compilers[0];
                StatusMessage = $"Found {compilers.Count} compiler{(compilers.Count == 1 ? "" : "s")}";
                DetectionDetails = $"Found {compilers.Count} compiler(s). Check the logs for search details.";
            }
            else
            {
                StatusMessage = "No compilers found";
                DetectionDetails = BuildNoCompilersFoundMessage();
                _logger.LogWarning("No compilers found on system");
            }
            
            _logger.LogInformation("Found {Count} compilers", compilers.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting compilers");
            StatusMessage = $"Error detecting compilers: {ex.Message}";
            DetectionDetails = $"Error: {ex.Message}";
        }
        finally
        {
            IsDetectingCompilers = false;
        }
    }

    private static string BuildNoCompilersFoundMessage()
    {
        var msg = "No C++ compilers were found on your system.\n\n";
        msg += "Fastest fix: click \"Download & Install MSYS2 (GCC)\" above to grab everything automatically.\n\n";
        msg += "Searched locations:\n";
        msg += "  - MSYS2 (C:\\msys64, D:\\msys64, etc.)\n";
        msg += "  - Git for Windows MinGW\n";
        msg += "  - Visual Studio Clang/LLVM\n";
        msg += "  - Standalone MinGW installations\n";
        msg += "  - System PATH\n\n";
        msg += "To compile Stockfish, you need MSYS2 with MinGW-w64:\n\n";
        msg += "1. Download MSYS2 from: https://www.msys2.org/\n";
        msg += "2. Install to default location (C:\\msys64)\n";
        msg += "3. Open MSYS2 MSYS terminal and run:\n";
        msg += "   pacman -Syu\n";
        msg += "   pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-make\n\n";
        msg += "4. Then click 'Detect Compilers' again.";
        return msg;
    }

    private async Task DetectOptimalArchitectureAsync()
    {
        if (SelectedCompiler is null)
        {
            _logger.LogWarning("Cannot detect architecture - no compiler selected");
            StatusMessage = "Please select a compiler first";
            return;
        }
        
        try
        {
            IsDetectingArchitecture = true;
            _logger.LogInformation("Detecting optimal architecture for {Compiler}", SelectedCompiler.DisplayName);
            StatusMessage = "Detecting optimal CPU architecture...";
            
            var optimalArch = await _architectureDetector.DetectOptimalArchitectureAsync(SelectedCompiler);
            SelectedArchitecture = AvailableArchitectures.FirstOrDefault(a => a.Id == optimalArch.Id) ?? optimalArch;
            StatusMessage = $"Detected: {optimalArch.Name}";
            
            _logger.LogInformation("Detected architecture: {Architecture}", optimalArch.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting architecture");
            StatusMessage = $"Error detecting architecture: {ex.Message}";
        }
        finally
        {
            IsDetectingArchitecture = false;
        }
    }

    private async Task LoadAvailableArchitectures()
    {
        try
        {
            _logger.LogInformation("Loading available architectures");
            var list = await _architectureDetector.GetAvailableArchitecturesAsync();
            AvailableArchitectures = new ObservableCollection<ArchitectureInfo>(list);
            _logger.LogInformation("Loaded {Count} architectures", list.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading architectures");
        }
    }

    private void LoadUserSettings()
    {
        try
        {
            _isRestoringSettings = true;
            _userSettings = _userSettingsService.Load();

            DownloadNetwork = _userSettings.DownloadNetwork;
            StripExecutable = _userSettings.StripExecutable;
            ParallelJobs = _userSettings.ParallelJobs;

            if (!string.IsNullOrWhiteSpace(_userSettings.OutputDirectory))
                OutputDirectory = _userSettings.OutputDirectory;

            if (!string.IsNullOrWhiteSpace(_userSettings.SourceVersion))
                SourceVersion = _userSettings.SourceVersion;

            _logger.LogInformation("Loaded user settings from {Path}", _userSettingsService.SettingsFilePath);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not load user settings, using defaults");
        }
        finally
        {
            _isRestoringSettings = false;
        }
    }

    private void PersistUserSettings()
    {
        if (_isRestoringSettings)
            return;

        _userSettings.DownloadNetwork = DownloadNetwork;
        _userSettings.StripExecutable = StripExecutable;
        _userSettings.ParallelJobs = ParallelJobs;
        _userSettings.OutputDirectory = OutputDirectory;
        _userSettings.SourceVersion = SourceVersion;

        _userSettingsService.Save(_userSettings);
    }

    partial void OnDownloadNetworkChanged(bool value) => PersistUserSettings();
    partial void OnStripExecutableChanged(bool value) => PersistUserSettings();
    partial void OnParallelJobsChanged(int value) => PersistUserSettings();
    partial void OnOutputDirectoryChanged(string value) => PersistUserSettings();
    partial void OnSourceVersionChanged(string value) => PersistUserSettings();

    public string SystemInfo => $"{OSHelper.GetFriendlyOSName()} | {RuntimeInformation.ProcessArchitecture} | .NET {Environment.Version}";
}

==== END FILE: ViewModels\MainViewModel.cs ====

==== BEGIN FILE: ViewModels\BuildViewModel.cs (D:\GitHub\StockfishCompiler\ViewModels\BuildViewModel.cs) ====
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;
using StockfishCompiler.Services;

namespace StockfishCompiler.ViewModels;

public partial class BuildViewModel : ObservableObject, IDisposable
{
    private readonly IBuildService _buildService;
    private readonly MainViewModel _mainViewModel;
    private readonly ILogger<BuildViewModel> _logger;
    private readonly List<IDisposable> _subscriptions = new();

    public BuildViewModel(IBuildService buildService, MainViewModel mainViewModel, ILogger<BuildViewModel> logger)
    {
        _buildService = buildService;
        _mainViewModel = mainViewModel;
        _logger = logger;

        _logger.LogInformation("BuildViewModel initializing");

        StartBuildCommand = new AsyncRelayCommand(StartBuildAsync, () => !IsBuilding);
        CancelBuildCommand = new RelayCommand(CancelBuild, () => IsBuilding);

        _subscriptions.Add(_buildService.Output.Subscribe(line => 
        {
            BuildOutput += line + Environment.NewLine;
        }));

        _subscriptions.Add(_buildService.Progress.Subscribe(p => BuildProgress = p));
        
        _subscriptions.Add(_buildService.IsBuilding.Subscribe(b => 
        {
            IsBuilding = b;
            StartBuildCommand.NotifyCanExecuteChanged();
            CancelBuildCommand.NotifyCanExecuteChanged();
        }));

        _logger.LogInformation("BuildViewModel initialized");
    }

    [ObservableProperty]
    private string buildOutput = string.Empty;

    [ObservableProperty]
    private double buildProgress = 0;

    [ObservableProperty]
    private bool isBuilding = false;

    public IAsyncRelayCommand StartBuildCommand { get; }
    public IRelayCommand CancelBuildCommand { get; }

    private async Task StartBuildAsync()
    {
        BuildOutput = string.Empty;
        BuildProgress = 0;

        _logger.LogInformation("Starting build process");

        var config = new BuildConfiguration
        {
            SelectedCompiler = _mainViewModel.SelectedCompiler,
            SelectedArchitecture = _mainViewModel.SelectedArchitecture,
            SourceVersion = _mainViewModel.SourceVersion,
            DownloadNetwork = _mainViewModel.DownloadNetwork,
            StripExecutable = _mainViewModel.StripExecutable,
            ParallelJobs = _mainViewModel.ParallelJobs,
            OutputDirectory = _mainViewModel.OutputDirectory
        };

        if (config.SelectedCompiler == null)
        {
            _logger.LogWarning("Build aborted - no compiler selected");
            BuildOutput = "Error: No compiler selected. Please go to Compiler Setup tab and detect compilers.\n";
            return;
        }

        if (config.SelectedArchitecture == null)
        {
            _logger.LogWarning("Build aborted - no architecture selected");
            BuildOutput = "Error: No architecture selected. Please go to Compiler Setup tab and detect architecture.\n";
            return;
        }

        _logger.LogInformation("Build configuration: Compiler={Compiler}, Arch={Arch}, Version={Version}, Jobs={Jobs}",
            config.SelectedCompiler.DisplayName,
            config.SelectedArchitecture.Id,
            config.SourceVersion,
            config.ParallelJobs);

        var result = await _buildService.BuildAsync(config);

        if (result.Success)
        {
            _logger.LogInformation("Build completed successfully");
            BuildOutput += "\n==============================================\n";
            BuildOutput += "Compilation successful!\n";
            BuildOutput += "==============================================\n";
        }
        else
        {
            _logger.LogError("Build failed with exit code {ExitCode}", result.ExitCode);
            BuildOutput += "\n==============================================\n";
            BuildOutput += "Compilation failed!\n";
            BuildOutput += $"Exit code: {result.ExitCode}\n";
            BuildOutput += "==============================================\n";
        }
    }

    private void CancelBuild()
    {
        _logger.LogInformation("Build cancelled by user");
        _buildService.CancelBuild();
        BuildOutput += "\n[Build cancelled by user]\n";
    }

    public void Dispose()
    {
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
        _subscriptions.Clear();
        GC.SuppressFinalize(this);
    }
}

==== END FILE: ViewModels\BuildViewModel.cs ====

==== BEGIN FILE: Models\ArchitectureInfo.cs (D:\GitHub\StockfishCompiler\Models\ArchitectureInfo.cs) ====
namespace StockfishCompiler.Models;

public class ArchitectureInfo
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty; // x86, ARM, PPC, etc.
    public bool IsRecommended { get; set; }
    public List<string> Features { get; set; } = [];

    public override string ToString() => Name;
}

==== END FILE: Models\ArchitectureInfo.cs ====

==== BEGIN FILE: Models\BuildConfiguration.cs (D:\GitHub\StockfishCompiler\Models\BuildConfiguration.cs) ====
namespace StockfishCompiler.Models;

public class BuildConfiguration
{
    public CompilerInfo? SelectedCompiler { get; set; }
    public ArchitectureInfo? SelectedArchitecture { get; set; }
    public string SourceVersion { get; set; } = "stable"; // stable, development
    public bool DownloadNetwork { get; set; } = true;
    public bool StripExecutable { get; set; } = true;
    public int ParallelJobs { get; set; } = Environment.ProcessorCount;
    public string OutputDirectory { get; set; } = string.Empty;
}

==== END FILE: Models\BuildConfiguration.cs ====

==== BEGIN FILE: Models\CompilationResult.cs (D:\GitHub\StockfishCompiler\Models\CompilationResult.cs) ====
namespace StockfishCompiler.Models;

public class CompilationResult
{
    public bool Success { get; set; }
    public string Output { get; set; } = string.Empty;
    public int ExitCode { get; set; }
}

==== END FILE: Models\CompilationResult.cs ====

==== BEGIN FILE: Models\CompilerInfo.cs (D:\GitHub\StockfishCompiler\Models\CompilerInfo.cs) ====
namespace StockfishCompiler.Models;

public class CompilerInfo
{
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty; // gcc, clang, msvc, mingw
    public string Version { get; set; } = string.Empty;
    public string Path { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public bool IsAvailable { get; set; }

    public override string ToString() => DisplayName;
}

==== END FILE: Models\CompilerInfo.cs ====

==== BEGIN FILE: Services\IArchitectureDetector.cs (D:\GitHub\StockfishCompiler\Services\IArchitectureDetector.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IArchitectureDetector
{
    Task<ArchitectureInfo> DetectOptimalArchitectureAsync(CompilerInfo compiler);
    Task<List<ArchitectureInfo>> GetAvailableArchitecturesAsync();
    Task<List<string>> DetectCPUFeaturesAsync(CompilerInfo compiler);
}

==== END FILE: Services\IArchitectureDetector.cs ====

==== BEGIN FILE: Services\ArchitectureDetector.cs (D:\GitHub\StockfishCompiler\Services\ArchitectureDetector.cs) ====
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class ArchitectureDetector : IArchitectureDetector
{
    private static readonly string[] X64BaseFeatures = ["sse4.1", "popcnt", "avx2", "bmi2"];
    private static readonly string[] Arm64BaseFeatures = ["neon", "popcnt"];
    private readonly ILogger<ArchitectureDetector> _logger;

    public ArchitectureDetector(ILogger<ArchitectureDetector> logger)
    {
        _logger = logger;
    }

    public async Task<ArchitectureInfo> DetectOptimalArchitectureAsync(CompilerInfo compiler)
    {
        var (features, detectedCpu) = await DetectCPUFeaturesDetailedAsync(compiler);
        _logger.LogDebug("Detected {Count} CPU features: {Features}", features.Count, string.Join(", ", features));
        _logger.LogDebug("Detected CPU name: {CpuName}", detectedCpu);
        
        var archId = DetermineOptimalArchitecture(features, detectedCpu);
        _logger.LogInformation("Determined optimal architecture: {Architecture}", archId);
        
        var all = await GetAvailableArchitecturesAsync();
        var matched = all.FirstOrDefault(a => a.Id.Equals(archId, StringComparison.OrdinalIgnoreCase));
        return matched ?? new ArchitectureInfo { Id = archId, Name = archId, Description = archId, Category = RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ? "ARM" : "x86" };
    }

    public async Task<List<string>> DetectCPUFeaturesAsync(CompilerInfo compiler)
    {
        var (features, _) = await DetectCPUFeaturesDetailedAsync(compiler);
        return features;
    }

    private async Task<(List<string> Features, string CpuName)> DetectCPUFeaturesDetailedAsync(CompilerInfo compiler)
    {
        try
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
            {
                _logger.LogInformation("ARM64 architecture detected, using base features");
                return (Arm64BaseFeatures.ToList(), "arm64");
            }

            if (compiler.Type is "gcc" or "mingw")
            {
                _logger.LogDebug("Using GCC feature detection for {Compiler}", compiler.DisplayName);
                return await DetectGccFeaturesAsync(compiler);
            }
            if (compiler.Type == "clang")
            {
                _logger.LogDebug("Using Clang feature detection for {Compiler}", compiler.DisplayName);
                return await DetectClangFeaturesAsync(compiler);
            }
            
            _logger.LogWarning("Unknown compiler type: {Type}, using fallback", compiler.Type);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Feature detection failed, using fallback features");
        }

        // Fallback minimal
        return (RuntimeInformation.ProcessArchitecture == Architecture.X64 ? X64BaseFeatures.ToList() : new List<string>(), RuntimeInformation.ProcessArchitecture.ToString().ToLowerInvariant());
    }

    private async Task<(List<string> Features, string CpuName)> DetectGccFeaturesAsync(CompilerInfo compiler)
    {
        var exe = Path.Combine(compiler.Path, compiler.Name);
        _logger.LogDebug("Running GCC detection: {Exe} -Q -march=native --help=target", exe);
        
        var psi = new ProcessStartInfo
        {
            FileName = exe,
            Arguments = "-Q -march=native --help=target",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        SetupEnvironmentForMSYS2(psi, compiler.Path);

        using var process = Process.Start(psi);
        if (process == null)
        {
            _logger.LogWarning("Failed to start GCC process for feature detection");
            return (X64BaseFeatures.ToList(), "unknown");
        }

        var stdoutTask = process.StandardOutput.ReadToEndAsync();
        var stderrTask = process.StandardError.ReadToEndAsync();
        
        await process.WaitForExitAsync();
        
        var stdout = await stdoutTask;
        var stderr = await stderrTask;

        if (process.ExitCode != 0)
        {
            _logger.LogWarning("GCC detection exited with code {ExitCode}", process.ExitCode);
            if (!string.IsNullOrWhiteSpace(stderr))
            {
                _logger.LogDebug("GCC stderr: {StdErr}", stderr.Substring(0, Math.Min(500, stderr.Length)));
            }
        }

        // If there were errors and no output, throw to trigger fallback
        if (process.ExitCode != 0 && string.IsNullOrWhiteSpace(stdout))
        {
            throw new InvalidOperationException($"GCC detection failed with exit code {process.ExitCode}");
        }

        var features = new List<string>();
        string cpuName = "";
        foreach (var line in stdout.Split('\n'))
        {
            var trimmed = line.Trim();
            if (trimmed.StartsWith("-march", StringComparison.Ordinal))
            {
                var parts = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                cpuName = parts.LastOrDefault() ?? string.Empty;
            }
            if (trimmed.Contains("[enabled]"))
            {
                var flag = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
                if (!string.IsNullOrEmpty(flag) && flag.StartsWith("-m"))
                {
                    var name = flag[2..];
                    features.Add(name);
                }
            }
        }

        _logger.LogDebug("GCC detection found {Count} features", features.Count);
        return (features.Distinct(StringComparer.OrdinalIgnoreCase).ToList(), cpuName);
    }

    private async Task<(List<string> Features, string CpuName)> DetectClangFeaturesAsync(CompilerInfo compiler)
    {
        var exe = Path.Combine(compiler.Path, compiler.Name);
        _logger.LogDebug("Running Clang detection: {Exe} -E - -march=native -###", exe);
        
        var psi = new ProcessStartInfo
        {
            FileName = exe,
            Arguments = "-E - -march=native -###",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        SetupEnvironmentForMSYS2(psi, compiler.Path);

        using var process = Process.Start(psi);
        if (process == null)
        {
            _logger.LogWarning("Failed to start Clang process for feature detection");
            return (X64BaseFeatures.ToList(), "unknown");
        }

        var stdoutTask = process.StandardOutput.ReadToEndAsync();
        var stderrTask = process.StandardError.ReadToEndAsync();
        
        await process.WaitForExitAsync();
        
        var stdout = await stdoutTask;
        var stderr = await stderrTask;

        var features = new List<string>();
        string cpuName = "";
        foreach (var line in stderr.Split('\n'))
        {
            var trimmed = line.Trim();
            if (trimmed.Contains("-target-cpu"))
            {
                var parts = trimmed.Split('"');
                cpuName = parts.LastOrDefault() ?? string.Empty;
            }
            if (trimmed.Contains("-target-feature"))
            {
                var parts = trimmed.Split('"');
                var feat = parts.LastOrDefault();
                if (!string.IsNullOrEmpty(feat) && feat.StartsWith('+'))
                {
                    features.Add(feat[1..]);
                }
            }
        }

        _logger.LogDebug("Clang detection found {Count} features", features.Count);
        return (features.Distinct(StringComparer.OrdinalIgnoreCase).ToList(), cpuName);
    }

    private void SetupEnvironmentForMSYS2(ProcessStartInfo psi, string compilerPath)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return;

        var compilerDir = new DirectoryInfo(compilerPath);
        var msys2Root = compilerDir.Parent?.Parent;

        if (msys2Root != null && msys2Root.Exists)
        {
            var pathsToAdd = new List<string>();

            pathsToAdd.Add(compilerPath);

            var usrBin = Path.Combine(msys2Root.FullName, "usr", "bin");
            var mingw64Bin = Path.Combine(msys2Root.FullName, "mingw64", "bin");
            var mingw32Bin = Path.Combine(msys2Root.FullName, "mingw32", "bin");

            if (Directory.Exists(usrBin))
                pathsToAdd.Add(usrBin);
            if (Directory.Exists(mingw64Bin))
                pathsToAdd.Add(mingw64Bin);
            if (Directory.Exists(mingw32Bin))
                pathsToAdd.Add(mingw32Bin);

            var currentPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
            var newPath = string.Join(";", pathsToAdd) + ";" + currentPath;
            psi.EnvironmentVariables["PATH"] = newPath;
            
            _logger.LogDebug("Set up MSYS2 environment with paths: {Paths}", string.Join("; ", pathsToAdd));
        }
        else
        {
            _logger.LogDebug("MSYS2 root not found for compiler path: {Path}", compilerPath);
        }
    }

    private static string DetermineOptimalArchitecture(List<string> features, string cpuName)
    {
        bool Has(params string[] req) => req.All(f => features.Contains(f));
        string cpu = cpuName.ToLowerInvariant();

        if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
            return "armv8";

        if (Has("avx512vnni", "avx512dq", "avx512f", "avx512bw", "avx512vl"))
            return "x86-64-vnni256";
        if (Has("avx512f", "avx512bw"))
            return "x86-64-avx512";
        if (Has("bmi2") && cpu is not ("znver1" or "znver2"))
            return "x86-64-bmi2";
        if (Has("avx2"))
            return "x86-64-avx2";
        if (Has("sse4.1", "popcnt"))
            return "x86-64-sse41-popcnt";
        if (Has("ssse3"))
            return "x86-64-ssse3";
        if (Has("sse3", "popcnt"))
            return "x86-64-sse3-popcnt";
        return "x86-64";
    }

    public Task<List<ArchitectureInfo>> GetAvailableArchitecturesAsync()
    {
        List<ArchitectureInfo> list =
        [
            new() { Id = "x86-64", Name = "x86-64", Description = "Generic 64-bit", Category = "x86" },
            new() { Id = "x86-64-vnni512", Name = "x86-64 VNNI 512", Description = "Intel Sapphire Rapids+, AMD Zen 4+", Category = "x86" },
            new() { Id = "x86-64-vnni256", Name = "x86-64 VNNI 256", Description = "Intel Cascade Lake+", Category = "x86" },
            new() { Id = "x86-64-avx512", Name = "x86-64 AVX-512", Description = "Intel Skylake-X+", Category = "x86" },
            new() { Id = "x86-64-bmi2", Name = "x86-64 BMI2", Description = "Intel Haswell+ (NOT AMD Zen 1/2)", Category = "x86" },
            new() { Id = "x86-64-avx2", Name = "x86-64 AVX2", Description = "Intel Haswell+, AMD Zen+", Category = "x86" },
            new() { Id = "x86-64-sse41-popcnt", Name = "x86-64 SSE4.1+POPCNT", Description = "Intel Nehalem+", Category = "x86" },
            new() { Id = "x86-64-ssse3", Name = "x86-64 SSSE3", Description = "Intel Core 2+, some early x86-64", Category = "x86" },
            new() { Id = "x86-64-sse3-popcnt", Name = "x86-64 SSE3+POPCNT", Description = "Older x86-64 with SSE3 + POPCNT", Category = "x86" },
            new() { Id = "armv8", Name = "ARMv8", Description = "ARMv8 64-bit with popcnt and neon", Category = "ARM" },
            new() { Id = "apple-silicon", Name = "Apple Silicon", Description = "Apple M1/M2/M3", Category = "ARM" }
        ];
        return Task.FromResult(list);
    }
}

==== END FILE: Services\ArchitectureDetector.cs ====

==== BEGIN FILE: Services\IBuildService.cs (D:\GitHub\StockfishCompiler\Services\IBuildService.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IBuildService
{
    IObservable<string> Output { get; }
    IObservable<double> Progress { get; }
    IObservable<bool> IsBuilding { get; }

    Task<CompilationResult> BuildAsync(BuildConfiguration configuration);
    void CancelBuild();
}

==== END FILE: Services\IBuildService.cs ====

==== BEGIN FILE: Services\BuildService.cs (D:\GitHub\StockfishCompiler\Services\BuildService.cs) ====
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Runtime.InteropServices;
using System.Security; // for SecurityException
using System.Text;
using System.Text.RegularExpressions;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class BuildService(IStockfishDownloader downloader) : IBuildService, IDisposable
{
    public IObservable<string> Output => _outputSubject.AsObservable();
    public IObservable<double> Progress => _progressSubject.AsObservable();
    public IObservable<bool> IsBuilding => _isBuildingSubject.AsObservable();

    private readonly Subject<string> _outputSubject = new();
    private readonly Subject<double> _progressSubject = new();
    private readonly Subject<bool> _isBuildingSubject = new();
    private CancellationTokenSource? _cts;
    private bool _disposed;

    private const int MaxOutputCharacters = 500_000; // safety cap

    public async Task<CompilationResult> BuildAsync(BuildConfiguration configuration)
    {
        _cts = new CancellationTokenSource();
        _isBuildingSubject.OnNext(true);
        _progressSubject.OnNext(0);
        SourceDownloadResult? downloadResult = null;

        try
        {
            var progress = new Progress<string>(msg => _outputSubject.OnNext(msg));

            // Download source
            _outputSubject.OnNext("Downloading Stockfish source...");
            downloadResult = await downloader.DownloadSourceAsync(configuration.SourceVersion, progress);
            var sourceDir = downloadResult.SourceDirectory;
            _progressSubject.OnNext(25);

            if (configuration.DownloadNetwork)
            {
                var networkReady = await downloader.DownloadNeuralNetworkAsync(sourceDir, configuration, progress);
                if (!networkReady)
                    _outputSubject.OnNext("Pre-download failed - make will attempt to fetch the network.");
                _progressSubject.OnNext(networkReady ? 40 : 30);
            }

            if (DisableNetDependency(sourceDir))
                _outputSubject.OnNext("Patched makefile to skip redundant net target.");
            if (NeutralizeNetScript(downloadResult.RootDirectory))
                _outputSubject.OnNext("Neutralized net.sh script to prevent redundant downloads.");
            if (PatchMakefileSaveTemps(sourceDir))
                _outputSubject.OnNext("Removed -save-temps flag to prevent network embedding issues.");
            if (CreatePlaceholderNetwork(sourceDir))
                _outputSubject.OnNext("Created placeholder network file for LTO linking.");

            // Verify neural network files are in place
            VerifyNetworkFiles(sourceDir);

            // Compile
            _outputSubject.OnNext("Compiling Stockfish...");
            var result = await CompileStockfishAsync(sourceDir, configuration, _cts.Token);
            _progressSubject.OnNext(90);

            // Strip and copy
            if (result.Success && configuration.StripExecutable)
            {
                _outputSubject.OnNext("Stripping executable...");
                await StripExecutableAsync(sourceDir, configuration, _cts.Token);
            }

            if (result.Success)
            {
                _outputSubject.OnNext("Copying executable...");
                CopyExecutable(sourceDir, configuration);
            }

            _progressSubject.OnNext(100);
            return result;
        }
        catch (OperationCanceledException)
        {
            return new CompilationResult { Success = false, Output = "Canceled", ExitCode = -1 };
        }
        finally
        {
            CleanupTempDirectoryWithRetry(downloadResult?.TempDirectory);
            _isBuildingSubject.OnNext(false);
        }
    }

    public void CancelBuild() => _cts?.Cancel();

    private async Task<CompilationResult> CompileStockfishAsync(string sourcePath, BuildConfiguration config, CancellationToken token)
    {
        var safeArch = SanitizeArchitecture(config.SelectedArchitecture?.Id);
        var safeJobs = SanitizeParallelJobs(config.ParallelJobs);
        var compType = GetCompType(config);
        var makeCmd = FindMakeCommand(config);
        var env = PrepareEnvironment(config);

        // Ensure PGO profile data lands in a short, writable path to avoid GCOV path explosions on Windows
        var profileDir = Path.Combine(Path.GetTempPath(), "sf_prof");
        try
        {
            if (Directory.Exists(profileDir))
                Directory.Delete(profileDir, true);
            Directory.CreateDirectory(profileDir);
            env["PROFDIR"] = profileDir;
            env["GCOV_PREFIX"] = profileDir;
            env["GCOV_PREFIX_STRIP"] = "10";
            env["LLVM_PROFILE_FILE"] = Path.Combine(profileDir, "default_%m.profraw");
        }
        catch
        {
            // If we cannot manage the profile directory, let GCC fall back; build will still succeed without PGO gains
        }

        _outputSubject.OnNext($"Using make: {makeCmd}");
        _outputSubject.OnNext($"Config: Jobs={safeJobs}, Arch={safeArch}, Comp={compType}");

        using var process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = makeCmd,
                WorkingDirectory = sourcePath,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            }
        };

        process.StartInfo.ArgumentList.Add($"-j{safeJobs}");
        process.StartInfo.ArgumentList.Add("profile-build");
        process.StartInfo.ArgumentList.Add($"ARCH={safeArch}");
        process.StartInfo.ArgumentList.Add($"COMP={compType}");

        foreach (var kvp in env)
            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;

        process.Start();

        using var registration = token.Register(() =>
        {
            try
            {
                if (!process.HasExited)
                    process.Kill(entireProcessTree: true);
            }
            catch
            {
                // Ignore kill failures; process may have already exited
            }
        });

        var outputBuilder = new StringBuilder();
        Task ReadAsync(StreamReader reader) => Task.Run(async () =>
        {
            while (!reader.EndOfStream)
            {
                token.ThrowIfCancellationRequested();
                var line = await reader.ReadLineAsync();
                if (line == null) break;
                AppendOutput(outputBuilder, line);
            }
        }, token);

        var readStdOut = ReadAsync(process.StandardOutput);
        var readStdErr = ReadAsync(process.StandardError);
        var waitExit = process.WaitForExitAsync(token);

        await Task.WhenAll(readStdOut, readStdErr, waitExit);

        return new CompilationResult
        {
            Success = process.ExitCode == 0,
            Output = outputBuilder.ToString(),
            ExitCode = process.ExitCode
        };
    }

    private void AppendOutput(StringBuilder builder, string line)
    {
        builder.AppendLine(line);
        if (builder.Length > MaxOutputCharacters)
            builder.Remove(0, builder.Length - MaxOutputCharacters); // trim oldest
        _outputSubject.OnNext(line);
    }

    private async Task StripExecutableAsync(string sourcePath, BuildConfiguration config, CancellationToken token)
    {
        var makeCmd = FindMakeCommand(config);
        var env = PrepareEnvironment(config);

        using var process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = makeCmd,
                Arguments = $"strip COMP={GetCompType(config)}",
                WorkingDirectory = sourcePath,
                RedirectStandardOutput = false,
                RedirectStandardError = false,
                UseShellExecute = false,
                CreateNoWindow = true
            }
        };
        foreach (var kvp in env)
            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;
        process.Start();
        await process.WaitForExitAsync(token);
    }

    private void CopyExecutable(string sourcePath, BuildConfiguration config)
    {
        var exeName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "stockfish.exe" : "stockfish";
        var sourceExe = Path.Combine(sourcePath, exeName);
        if (!File.Exists(sourceExe))
        {
            _outputSubject.OnNext($"Warning: Could not find {sourceExe}");
            return;
        }
        var safeArch = SanitizeArchitecture(config.SelectedArchitecture?.Id);
        var outputNameRaw = $"stockfish_{safeArch}_{config.SourceVersion}{(RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : "")}";
        var outputPath = ValidateOutputPath(config.OutputDirectory, outputNameRaw);
        File.Copy(sourceExe, outputPath, true);
        _outputSubject.OnNext($"Executable saved to: {outputPath}");
    }

    private static string GetCompType(BuildConfiguration config)
    {
        if (config.SelectedCompiler == null) return "gcc";
        return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && config.SelectedCompiler.Type == "gcc" ? "mingw" : config.SelectedCompiler.Type;
    }

    private static string FindMakeCommand(BuildConfiguration config)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return "make";
        if (config.SelectedCompiler?.Path != null)
        {
            var compilerPath = new DirectoryInfo(config.SelectedCompiler.Path);
            var msys2Root = compilerPath.Parent?.Parent;
            if (msys2Root != null && msys2Root.Exists)
            {
                var makePaths = new[]
                {
                    Path.Combine(msys2Root.FullName, "usr", "bin", "make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "mingw32-make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "make.exe")
                };
                foreach (var makePath in makePaths)
                    if (File.Exists(makePath)) return makePath;
            }
        }
        var commonMsys2Paths = new[] { @"C:\msys64", @"C:\msys2", @"D:\msys64", @"D:\msys2" };
        foreach (var msys2Path in commonMsys2Paths)
        {
            var makePaths = new[]
            {
                Path.Combine(msys2Path, "usr", "bin", "make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "mingw32-make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "make.exe")
            };
            foreach (var makePath in makePaths)
                if (File.Exists(makePath)) return makePath;
        }
        return "make";
    }

    private static bool DisableNetDependency(string sourceDirectory)
    {
        var makefilePath = Path.Combine(sourceDirectory, "Makefile");
        if (!File.Exists(makefilePath)) return false;
        var lines = File.ReadAllLines(makefilePath);
        var changed = false;
        var targetsToPatch = new[] { "profile-build:", "build:", "config-sanity:", "analyze:" };
        for (int i = 0; i < lines.Length; i++)
        {
            foreach (var target in targetsToPatch)
            {
                if (lines[i].StartsWith(target, StringComparison.Ordinal))
                {
                    var updated = RemoveMakeDependency(lines[i], "net");
                    if (!string.Equals(updated, lines[i], StringComparison.Ordinal))
                    {
                        lines[i] = updated;
                        changed = true;
                    }
                    break;
                }
            }
        }
        if (changed) File.WriteAllLines(makefilePath, lines);
        return changed;
    }

    private bool NeutralizeNetScript(string rootDirectory)
    {
        if (string.IsNullOrWhiteSpace(rootDirectory)) return false;
        var scriptPath = Path.Combine(rootDirectory, "scripts", "net.sh");
        if (!File.Exists(scriptPath)) return false;
        var scriptContent = """
#!/bin/sh
echo "Skipping Stockfish net target - neural networks pre-downloaded."
exit 0
""";
        File.WriteAllText(scriptPath, scriptContent.Replace("\r\n", "\n"));
        return true;
    }

    private static bool PatchMakefileSaveTemps(string sourceDirectory)
    {
        var makefilePath = Path.Combine(sourceDirectory, "Makefile");
        if (!File.Exists(makefilePath)) return false;
        
        var content = File.ReadAllText(makefilePath);
        var originalContent = content;
        
        // Remove -save-temps flag (as a standalone word, not adjacent whitespace)
        // Uses lookbehind (?<=\s) to ensure preceded by whitespace
        // Uses lookahead (?=\s|$) to ensure followed by whitespace or end of line
        // This preserves Makefile syntax and line continuations
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"(?<=\s)-save-temps(?=\s|$)",
            "",
            System.Text.RegularExpressions.RegexOptions.Multiline
        );
        
        if (content != originalContent)
        {
            File.WriteAllText(makefilePath, content);
            return true;
        }
        
        return false;
    }

    private static bool CreatePlaceholderNetwork(string sourceDirectory)
    {
        // If valid networks are already present, nothing to do.
        if (Directory.GetFiles(sourceDirectory, "*.nnue").Any())
            return false;

        var targetNames = DetectNetworkNames(sourceDirectory);
        if (targetNames.Count == 0)
            targetNames.Add("nn-1c0000000000.nnue"); // fallback to classic default

        var dummyData = new byte[1024];
        dummyData[0] = 0x4E; // N
        dummyData[1] = 0x4E; // N
        dummyData[2] = 0x55; // U
        dummyData[3] = 0x45; // E

        var created = false;
        foreach (var name in targetNames)
        {
            var path = Path.Combine(sourceDirectory, name);
            if (!File.Exists(path))
            {
                File.WriteAllBytes(path, dummyData);
                created = true;
            }
        }

        return created;
    }

    private static List<string> DetectNetworkNames(string sourceDirectory)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var candidates = new[]
        {
            Path.Combine(sourceDirectory, "evaluate.h"),
            Path.Combine(sourceDirectory, "nnue", "evaluate.h")
        };

        var regex = new Regex("#define\\s+EvalFileDefaultName\\w*\\s+\"(nn-[a-z0-9]{12}\\.nnue)\"", RegexOptions.IgnoreCase);

        foreach (var candidate in candidates)
        {
            if (!File.Exists(candidate)) continue;
            var contents = File.ReadAllText(candidate);
            foreach (Match m in regex.Matches(contents))
            {
                if (m.Success)
                    names.Add(m.Groups[1].Value);
            }
        }

        return names.ToList();
    }

    private void VerifyNetworkFiles(string sourceDirectory)
    {
        var nnueFiles = Directory.GetFiles(sourceDirectory, "*.nnue");
        if (nnueFiles.Length > 0)
        {
            _outputSubject.OnNext($"Network files present: {string.Join(", ", nnueFiles.Select(Path.GetFileName))}");
        }
        else
        {
            _outputSubject.OnNext("Warning: No .nnue files found in source directory!");
        }
    }

    private void CleanupTempDirectoryWithRetry(string? tempDirectory)
    {
        if (string.IsNullOrWhiteSpace(tempDirectory)) return;
        if (!Directory.Exists(tempDirectory)) return;
        const int maxRetries = 3;
        for (int attempt = 1; attempt <= maxRetries; attempt++)
        {
            try
            {
                Directory.Delete(tempDirectory, true);
                _outputSubject.OnNext($"Cleaned up temporary Stockfish source directory.");
                return;
            }
            catch (IOException) when (attempt < maxRetries)
            {
                Thread.Sleep(250 * attempt);
            }
            catch (UnauthorizedAccessException) when (attempt < maxRetries)
            {
                Thread.Sleep(250 * attempt);
            }
            catch (Exception ex)
            {
                _outputSubject.OnNext($"Warning: Could not delete temp directory {tempDirectory}: {ex.Message}");
                return;
            }
        }
        if (Directory.Exists(tempDirectory))
            _outputSubject.OnNext($"Warning: Temp directory persists: {tempDirectory}");
    }

    private static string RemoveMakeDependency(string line, string dependency)
    {
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return line;
        var targetPart = line[..(colonIndex + 1)];
        var rest = line[(colonIndex + 1)..];
        var tokens = rest.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        var filtered = tokens.Where(t => !t.Equals(dependency, StringComparison.Ordinal)).ToArray();
        var newRest = filtered.Length > 0 ? " " + string.Join(' ', filtered) : string.Empty;
        var updatedLine = targetPart + newRest;
        return updatedLine == line ? line : updatedLine;
    }

    private static Dictionary<string, string> PrepareEnvironment(BuildConfiguration config)
    {
        var env = new Dictionary<string, string>();
        foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
            if (entry.Key != null && entry.Value != null)
                env[entry.Key.ToString()!] = entry.Value.ToString()!;
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) return env;
        var pathsToAdd = new List<string>();
        if (config.SelectedCompiler?.Path != null)
        {
            pathsToAdd.Add(config.SelectedCompiler.Path);
            var compilerPath = new DirectoryInfo(config.SelectedCompiler.Path);
            var msys2Root = compilerPath.Parent?.Parent;
            if (msys2Root != null && msys2Root.Exists)
            {
                var usrBin = Path.Combine(msys2Root.FullName, "usr", "bin");
                var mingw64Bin = Path.Combine(msys2Root.FullName, "mingw64", "bin");
                if (Directory.Exists(usrBin)) pathsToAdd.Add(usrBin);
                if (Directory.Exists(mingw64Bin)) pathsToAdd.Add(mingw64Bin);
            }
        }
        else
        {
            var commonMsys2Paths = new[] { @"C:\msys64", @"C:\msys2", @"D:\msys64", @"D:\msys2" };
            foreach (var msys2Path in commonMsys2Paths)
            {
                if (!Directory.Exists(msys2Path)) continue;
                var usrBin = Path.Combine(msys2Path, "usr", "bin");
                var mingw64Bin = Path.Combine(msys2Path, "mingw64", "bin");
                if (Directory.Exists(usrBin)) pathsToAdd.Add(usrBin);
                if (Directory.Exists(mingw64Bin)) pathsToAdd.Add(mingw64Bin);
                if (pathsToAdd.Count > 0) break;
            }
        }
        if (pathsToAdd.Count > 0)
        {
            var currentPath = env.GetValueOrDefault("PATH", string.Empty);
            env["PATH"] = string.Join(";", pathsToAdd) + ";" + currentPath;
        }
        return env;
    }

    private static string SanitizeArchitecture(string? arch)
    {
        if (string.IsNullOrWhiteSpace(arch)) return "x86-64";
        var validArchs = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "x86-64","x86-64-vnni512","x86-64-vnni256","x86-64-avx512","x86-64-bmi2","x86-64-avx2","x86-64-sse41-popcnt","x86-64-ssse3","x86-64-sse3-popcnt","armv8","apple-silicon"
        };
        return validArchs.Contains(arch) ? arch : "x86-64";
    }

    private static int SanitizeParallelJobs(int jobs)
    {
        var max = Environment.ProcessorCount * 2;
        if (jobs < 1) return 1;
        if (jobs > max) return max;
        return jobs;
    }

    private static string ValidateOutputPath(string outputDirectory, string filename)
    {
        if (string.IsNullOrWhiteSpace(outputDirectory)) throw new SecurityException("Output directory not specified");

        var baseName = Path.GetFileName(filename);
        if (!string.Equals(baseName, filename, StringComparison.Ordinal)) throw new SecurityException("Invalid output file name");
        if (baseName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) throw new SecurityException("Invalid characters in output file name");

        var ext = Path.GetExtension(baseName);
        if (!string.IsNullOrEmpty(ext) && !ext.Equals(".exe", StringComparison.OrdinalIgnoreCase))
            throw new SecurityException("Disallowed file extension");

        var normalizedDir = Path.GetFullPath(outputDirectory);
        var systemDirs = new[]
        {
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            Environment.GetFolderPath(Environment.SpecialFolder.Windows),
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)
        };
        if (systemDirs.Any(d => !string.IsNullOrEmpty(d) && normalizedDir.StartsWith(d, StringComparison.OrdinalIgnoreCase)))
            throw new SecurityException("Refusing to write into system directory");

        Directory.CreateDirectory(normalizedDir);
        var fullPath = Path.GetFullPath(Path.Combine(normalizedDir, baseName));
        if (!fullPath.StartsWith(normalizedDir, StringComparison.OrdinalIgnoreCase)) throw new SecurityException("Path traversal detected");
        return fullPath;
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        _cts?.Dispose();
        _outputSubject.Dispose();
        _progressSubject.Dispose();
        _isBuildingSubject.Dispose();
    }
}

==== END FILE: Services\BuildService.cs ====

==== BEGIN FILE: Services\ICompilerService.cs (D:\GitHub\StockfishCompiler\Services\ICompilerService.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface ICompilerService
{
    Task<List<CompilerInfo>> DetectCompilersAsync();
    Task<bool> ValidateCompilerAsync(CompilerInfo compiler);
    Task<string> GetCompilerVersionAsync(string compilerPath);
}

==== END FILE: Services\ICompilerService.cs ====

==== BEGIN FILE: Services\CompilerService.cs (D:\GitHub\StockfishCompiler\Services\CompilerService.cs) ====
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class CompilerService(ILogger<CompilerService> logger) : ICompilerService
{
    private static readonly string[] PathCandidates = ["g++", "clang++", "gcc", "clang"];

    public async Task<List<CompilerInfo>> DetectCompilersAsync()
    {
        logger.LogInformation("Starting comprehensive compiler detection");
        List<CompilerInfo> compilers = [];

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            compilers.AddRange(await DetectMSYS2CompilersAsync());
            compilers.AddRange(await DetectGitForWindowsCompilersAsync());
            compilers.AddRange(await DetectVisualStudioCompilersAsync());
            compilers.AddRange(await DetectMinGWStandaloneAsync());
            compilers.AddRange(await DetectPathCompilersAsync());
        }
        else
        {
            compilers.AddRange(await DetectUnixCompilersAsync());
        }

        logger.LogInformation("Total compilers found before deduplication: {Count}", compilers.Count);
        
        // Distinct by Path + Name
        var uniqueCompilers = compilers
            .GroupBy(c => c.Path + "|" + c.Name)
            .Select(g => g.First())
            .ToList();

        logger.LogInformation("Unique compilers after deduplication: {Count}", uniqueCompilers.Count);
        return uniqueCompilers;
    }

    public Task<bool> ValidateCompilerAsync(CompilerInfo compiler)
    {
        var exe = compiler.Name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ? compiler.Name : compiler.Name + ".exe";
        var fullPath = string.IsNullOrEmpty(compiler.Path) ? exe : Path.Combine(compiler.Path, exe);
        return Task.FromResult(File.Exists(fullPath));
    }

    public async Task<string> GetCompilerVersionAsync(string compilerPath)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = compilerPath,
                Arguments = "--version",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null)
                return string.Empty;

            var output = await process.StandardOutput.ReadToEndAsync();
            await process.WaitForExitAsync();
            var firstLine = output.Split('\n').FirstOrDefault()?.Trim() ?? string.Empty;
            return firstLine;
        }
        catch (Exception ex)
        {
            logger.LogDebug(ex, "Failed to get version for {Path}", compilerPath);
            return string.Empty;
        }
    }

    private async Task<List<CompilerInfo>> DetectMSYS2CompilersAsync()
    {
        logger.LogInformation("Searching for MSYS2 installations");
        List<CompilerInfo> compilers = [];
        
        // Search common locations across all drives
        var drives = DriveInfo.GetDrives()
            .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
            .Select(d => d.Name.TrimEnd('\\'))
            .ToList();

        logger.LogInformation("Searching drives: {Drives}", string.Join(", ", drives));

        var possiblePaths = new List<string>();
        
        foreach (var drive in drives)
        {
            // Add root level msys2/msys64 paths
            possiblePaths.Add(Path.Combine(drive, "msys64"));
            possiblePaths.Add(Path.Combine(drive, "msys2"));
            
            // Check Program Files
            possiblePaths.Add(Path.Combine(drive, "Program Files", "msys64"));
            possiblePaths.Add(Path.Combine(drive, "Program Files", "msys2"));
            
            // Check tools directories
            possiblePaths.Add(Path.Combine(drive, "tools", "msys64"));
            possiblePaths.Add(Path.Combine(drive, "tools", "msys2"));
        }

        // Add user profile paths
        possiblePaths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys64"));
        possiblePaths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys2"));
        possiblePaths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "msys64"));
        possiblePaths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "msys2"));

        // Check environment variable
        var msysEnvVar = Environment.GetEnvironmentVariable("MSYS2_PATH");
        if (!string.IsNullOrEmpty(msysEnvVar))
        {
            possiblePaths.Add(msysEnvVar);
        }

        // Remove duplicates and check which paths exist
        possiblePaths = possiblePaths.Distinct(StringComparer.OrdinalIgnoreCase).ToList();

        foreach (var basePath in possiblePaths.Where(Directory.Exists))
        {
            logger.LogInformation("Found MSYS2 at: {Path}", basePath);
            
            var msysPaths = new[]
            {
                Path.Combine(basePath, "mingw64", "bin"),
                Path.Combine(basePath, "mingw32", "bin"),
                Path.Combine(basePath, "ucrt64", "bin"),
                Path.Combine(basePath, "clang64", "bin"),
                Path.Combine(basePath, "clang32", "bin"),
                Path.Combine(basePath, "clangarm64", "bin")
            };

            foreach (var path in msysPaths.Where(Directory.Exists))
            {
                logger.LogDebug("Checking MSYS2 path: {Path}", path);
                
                var gcc = Path.Combine(path, "g++.exe");
                var clang = Path.Combine(path, "clang++.exe");

                if (File.Exists(gcc))
                {
                    logger.LogInformation("Found g++ at: {Path}", gcc);
                    var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                    compilerInfo.DisplayName = $"MSYS2 GCC - {Path.GetFileName(Path.GetDirectoryName(path))} ({basePath})";
                    compilers.Add(compilerInfo);
                }
                if (File.Exists(clang))
                {
                    logger.LogInformation("Found clang++ at: {Path}", clang);
                    var compilerInfo = await CreateCompilerInfoAsync(clang, "clang");
                    compilerInfo.DisplayName = $"MSYS2 Clang - {Path.GetFileName(Path.GetDirectoryName(path))} ({basePath})";
                    compilers.Add(compilerInfo);
                }
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectGitForWindowsCompilersAsync()
    {
        logger.LogInformation("Searching for Git for Windows");
        List<CompilerInfo> compilers = [];

        var gitPaths = new[]
        {
            @"C:\Program Files\Git\mingw64\bin",
            @"C:\Program Files (x86)\Git\mingw64\bin",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Programs", "Git", "mingw64", "bin")
        };

        foreach (var path in gitPaths.Where(Directory.Exists))
        {
            logger.LogInformation("Found Git for Windows at: {Path}", path);
            
            var gcc = Path.Combine(path, "g++.exe");
            if (File.Exists(gcc))
            {
                logger.LogInformation("Found g++ in Git: {Path}", gcc);
                var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                compilerInfo.DisplayName = $"Git for Windows GCC ({path})";
                compilers.Add(compilerInfo);
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectVisualStudioCompilersAsync()
    {
        logger.LogInformation("Searching for Visual Studio compilers");
        List<CompilerInfo> compilers = [];

        // Check for VS Build Tools and full VS installations
        var vsYears = new[] { "2022", "2019", "2017" };
        var vsEditions = new[] { "Community", "Professional", "Enterprise", "BuildTools", "Preview" };
        
        foreach (var year in vsYears)
        {
            foreach (var edition in vsEditions)
            {
                // Check for Clang/LLVM
                var clangPaths = new[]
                {
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\x64\bin",
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\bin",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\x64\bin",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\bin"
                };

                foreach (var path in clangPaths.Where(Directory.Exists))
                {
                    logger.LogInformation("Found Visual Studio Clang at: {Path}", path);
                    
                    var clang = Path.Combine(path, "clang++.exe");
                    if (File.Exists(clang))
                    {
                        logger.LogInformation("Found clang++ in VS: {Path}", clang);
                        var compilerInfo = await CreateCompilerInfoAsync(clang, "clang");
                        compilerInfo.DisplayName = $"Visual Studio {year} {edition} - Clang/LLVM";
                        compilers.Add(compilerInfo);
                    }
                }

                // Check for MSVC (cl.exe)
                var msvcPaths = new[]
                {
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\MSVC",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\MSVC"
                };

                foreach (var basePath in msvcPaths.Where(Directory.Exists))
                {
                    try
                    {
                        var msvcVersionDirs = Directory.GetDirectories(basePath);
                        foreach (var versionDir in msvcVersionDirs)
                        {
                            var clPath = Path.Combine(versionDir, "bin", "Hostx64", "x64", "cl.exe");
                            if (File.Exists(clPath))
                            {
                                logger.LogInformation("Found MSVC cl.exe at: {Path}", clPath);
                                var version = await GetMSVCVersionAsync(clPath);
                                var compilerInfo = new CompilerInfo
                                {
                                    Name = "cl.exe",
                                    Type = "msvc",
                                    Version = version,
                                    Path = Path.GetDirectoryName(clPath) ?? string.Empty,
                                    DisplayName = $"Visual Studio {year} {edition} - MSVC ({Path.GetFileName(versionDir)})",
                                    IsAvailable = true
                                };
                                compilers.Add(compilerInfo);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        logger.LogDebug(ex, "Error checking MSVC path: {Path}", basePath);
                    }
                }
            }
        }

        return compilers;
    }

    private async Task<string> GetMSVCVersionAsync(string clPath)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = clPath,
                Arguments = "",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null)
                return "Unknown version";

            var error = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();
            
            // MSVC outputs version info to stderr
            var firstLine = error.Split('\n').FirstOrDefault()?.Trim() ?? string.Empty;
            return firstLine.Length > 100 ? firstLine.Substring(0, 100) + "..." : firstLine;
        }
        catch (Exception ex)
        {
            logger.LogDebug(ex, "Failed to get MSVC version for {Path}", clPath);
            return "Unknown version";
        }
    }

    private async Task<List<CompilerInfo>> DetectMinGWStandaloneAsync()
    {
        logger.LogInformation("Searching for standalone MinGW");
        List<CompilerInfo> compilers = [];

        var mingwPaths = new List<string>
        {
            @"C:\MinGW\bin",
            @"C:\MinGW-w64\bin",
            @"C:\mingw64\bin",
            @"D:\MinGW\bin",
            @"D:\mingw64\bin",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "MinGW", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "MinGW", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "mingw64", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "mingw64", "bin")
        };

        // Check all drives for common MinGW locations
        var drives = DriveInfo.GetDrives()
            .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
            .Select(d => d.Name.TrimEnd('\\'));

        foreach (var drive in drives)
        {
            mingwPaths.Add(Path.Combine(drive, "MinGW", "bin"));
            mingwPaths.Add(Path.Combine(drive, "mingw64", "bin"));
            mingwPaths.Add(Path.Combine(drive, "MinGW-w64", "bin"));
        }

        foreach (var path in mingwPaths.Distinct().Where(Directory.Exists))
        {
            logger.LogInformation("Found MinGW at: {Path}", path);
            
            var gcc = Path.Combine(path, "g++.exe");
            if (File.Exists(gcc))
            {
                logger.LogInformation("Found g++ in MinGW: {Path}", gcc);
                var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                compilerInfo.DisplayName = $"Standalone MinGW GCC ({path})";
                compilers.Add(compilerInfo);
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectPathCompilersAsync()
    {
        logger.LogInformation("Searching for compilers in PATH");
        List<CompilerInfo> compilers = [];

        foreach (var c in PathCandidates)
        {
            var path = await WhichAsync(c);
            if (!string.IsNullOrEmpty(path))
            {
                logger.LogInformation("Found {Command} in PATH: {Path}", c, path);
                var type = c.Contains("clang") ? "clang" : "gcc";
                var compilerInfo = await CreateCompilerInfoAsync(path, type);
                compilerInfo.DisplayName = $"{type.ToUpper()} in PATH - {Path.GetDirectoryName(path)}";
                compilers.Add(compilerInfo);
            }
        }
        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectUnixCompilersAsync()
    {
        logger.LogInformation("Searching for Unix compilers");
        List<CompilerInfo> compilers = [];
        
        foreach (var c in PathCandidates)
        {
            var path = await WhichAsync(c);
            if (!string.IsNullOrEmpty(path))
            {
                logger.LogInformation("Found {Command}: {Path}", c, path);
                var type = c.Contains("clang") ? "clang" : "gcc";
                compilers.Add(await CreateCompilerInfoAsync(path, type));
            }
        }
        return compilers;
    }

    private async Task<CompilerInfo> CreateCompilerInfoAsync(string compilerFullPath, string type)
    {
        var version = await GetCompilerVersionAsync(compilerFullPath);
        var shortVersion = version.Length > 50 ? version.Substring(0, 50) + "..." : version;
        
        return new CompilerInfo
        {
            Name = Path.GetFileName(compilerFullPath),
            Type = type,
            Version = shortVersion,
            Path = Path.GetDirectoryName(compilerFullPath) ?? string.Empty,
            DisplayName = $"{type.ToUpper()} - {Path.GetDirectoryName(compilerFullPath)}",
            IsAvailable = true
        };
    }

    private static readonly string[] LineSeparators = ["\r", "\n"];
    
    private static async Task<string> WhichAsync(string command)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "where" : "which",
                Arguments = command,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null) return string.Empty;
            var output = await process.StandardOutput.ReadToEndAsync();
            await process.WaitForExitAsync();
            var first = output.Split(LineSeparators, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
            return first ?? string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }
}

==== END FILE: Services\CompilerService.cs ====

==== BEGIN FILE: Services\IStockfishDownloader.cs (D:\GitHub\StockfishCompiler\Services\IStockfishDownloader.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IStockfishDownloader
{
    Task<SourceDownloadResult> DownloadSourceAsync(string version, IProgress<string>? progress = null);
    Task<bool> DownloadNeuralNetworkAsync(string sourceDirectory, BuildConfiguration? config = null, IProgress<string>? progress = null);
    Task<ReleaseInfo?> GetLatestReleaseAsync();
}

public class ReleaseInfo
{
    public string Version { get; set; } = string.Empty;
    public string Url { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
}

public class SourceDownloadResult
{
    public string SourceDirectory { get; set; } = string.Empty;
    public string RootDirectory { get; set; } = string.Empty;
    public string TempDirectory { get; set; } = string.Empty;
}

==== END FILE: Services\IStockfishDownloader.cs ====

==== BEGIN FILE: Services\StockfishDownloader.cs (D:\GitHub\StockfishCompiler\Services\StockfishDownloader.cs) ====
using System.IO;
using System.IO.Compression;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text.Json;
using System.Text.RegularExpressions;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class StockfishDownloader : IStockfishDownloader
{
    private readonly HttpClient _httpClient;
    private const string GitHubApiUrl = "https://api.github.com/repos/official-stockfish/Stockfish/releases/latest";
    private const string MasterZipUrl = "https://github.com/official-stockfish/Stockfish/archive/refs/heads/master.zip";
    private static readonly string[] NetworkMirrors =
    [
        "https://tests.stockfishchess.org/api/nn/{0}",
        "https://github.com/official-stockfish/networks/raw/master/{0}"
    ];
    private static readonly Regex NetworkMacroRegex = new("#define\\s+EvalFileDefaultName\\w*\\s+\"(nn-[a-z0-9]{12}\\.nnue)\"", RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromSeconds(1));
    private static readonly Regex NetworkFileNameRegex = new("nn-([a-f0-9]{12})\\.nnue", RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromSeconds(1));
    private const long MaxDownloadSize = 500L * 1024 * 1024; // 500 MB safety cap

    public StockfishDownloader(HttpClient httpClient)
    {
        _httpClient = httpClient;
        EnsureUserAgent();
    }

    public async Task<ReleaseInfo?> GetLatestReleaseAsync()
    {
        try
        {
            EnsureUserAgent();
            using var response = await _httpClient.GetAsync(GitHubApiUrl, HttpCompletionOption.ResponseHeadersRead);
            response.EnsureSuccessStatusCode();
            using var stream = await response.Content.ReadAsStreamAsync();
            using var doc = await JsonDocument.ParseAsync(stream);
            var root = doc.RootElement;
            return new ReleaseInfo
            {
                Version = root.GetProperty("tag_name").GetString() ?? "unknown",
                Url = root.GetProperty("zipball_url").GetString() ?? string.Empty,
                Name = root.GetProperty("name").GetString() ?? "Latest Release"
            };
        }
        catch
        {
            return null;
        }
    }

    public async Task<SourceDownloadResult> DownloadSourceAsync(string version, IProgress<string>? progress = null)
    {
        progress?.Report($"Downloading Stockfish {version}...");

        var tempDir = Path.Combine(Path.GetTempPath(), $"stockfish_build_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempDir);

        var zipPath = Path.Combine(tempDir, "stockfish.zip");
        var url = version == "master" ? MasterZipUrl : (await GetLatestReleaseAsync())?.Url ?? MasterZipUrl;

        EnsureUserAgent();
        await SafeDownloadToFileAsync(url, zipPath, progress);

        progress?.Report("Extracting source code...");
        SafeExtractToDirectory(zipPath, tempDir);

        var extractedDirs = Directory.GetDirectories(tempDir).Where(d => d.Contains("Stockfish", StringComparison.OrdinalIgnoreCase)).ToArray();
        if (extractedDirs.Length == 0)
            throw new Exception("Could not find extracted Stockfish directory");

        var rootDir = extractedDirs[0];
        var sourceDir = Path.Combine(rootDir, "src");
        if (!Directory.Exists(sourceDir))
            throw new Exception($"Source directory not found: {sourceDir}");

        progress?.Report($"Source extracted to: {sourceDir}");
        return new SourceDownloadResult
        {
            SourceDirectory = sourceDir,
            RootDirectory = rootDir,
            TempDirectory = tempDir
        };
    }

    public async Task<bool> DownloadNeuralNetworkAsync(string sourceDirectory, BuildConfiguration? config = null, IProgress<string>? progress = null)
    {
        progress?.Report("Preparing NNUE neural networks...");

        var networkFiles = DetectNetworkFileNames(sourceDirectory);
        if (networkFiles.Count == 0)
        {
            progress?.Report("Could not determine default network files - build will attempt to download them.");
            return false;
        }

        var overallSuccess = true;

        foreach (var networkFile in networkFiles)
        {
            var destination = Path.Combine(sourceDirectory, networkFile);
            if (File.Exists(destination))
            {
                var existing = await File.ReadAllBytesAsync(destination);
                if (ValidateNetworkBytes(existing, networkFile))
                {
                    progress?.Report($"{networkFile} already present and validated.");
                    continue;
                }

                progress?.Report($"{networkFile} exists but failed validation - re-downloading.");
            }

            var downloaded = false;
            foreach (var urlTemplate in NetworkMirrors)
            {
                var url = string.Format(urlTemplate, networkFile);
                try
                {
                    progress?.Report($"Downloading {networkFile} from {url}...");
                    EnsureUserAgent();
                    
                    var tempNetPath = destination + ".tmp";
                    await SafeDownloadToFileAsync(url, tempNetPath, progress);

                    var bytes = await File.ReadAllBytesAsync(tempNetPath);
                    if (!ValidateNetworkBytes(bytes, networkFile))
                    {
                        progress?.Report($"Downloaded {networkFile} from {url} failed validation.");
                        File.Delete(tempNetPath);
                        continue;
                    }

                    File.Move(tempNetPath, destination, true);
                    progress?.Report($"Saved {networkFile} ({bytes.Length / 1024 / 1024.0:F1} MB).");
                    downloaded = true;
                    break;
                }
                catch (Exception ex)
                {
                    progress?.Report($"Failed to download {networkFile} from {url} ({ex.Message}).");
                }
            }

            if (!downloaded)
            {
                overallSuccess = false;
                progress?.Report($"Unable to download {networkFile} - make will retry during build.");
            }
        }

        return overallSuccess;
    }

    private async Task SafeDownloadToFileAsync(string url, string destinationPath, IProgress<string>? progress)
    {
        using var response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
        response.EnsureSuccessStatusCode();

        var totalBytes = response.Content.Headers.ContentLength ?? -1L;
        if (totalBytes > MaxDownloadSize)
            throw new InvalidOperationException($"Download too large: {totalBytes} bytes");

        using var stream = await response.Content.ReadAsStreamAsync();
        using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None, 8192, true);

        var buffer = new byte[8192];
        long totalRead = 0;
        int bytesRead;

        while ((bytesRead = await stream.ReadAsync(buffer)) != 0)
        {
            await fileStream.WriteAsync(buffer.AsMemory(0, bytesRead));
            totalRead += bytesRead;

            if (totalRead > MaxDownloadSize)
                throw new InvalidOperationException("Download exceeded maximum size");
        }
    }

    private static void SafeExtractToDirectory(string zipPath, string destinationDirectory)
    {
        using var archive = ZipFile.OpenRead(zipPath);
        var destDirFullPath = Path.GetFullPath(destinationDirectory);

        foreach (var entry in archive.Entries)
        {
            if (string.IsNullOrEmpty(entry.Name)) continue;

            var completeFileName = Path.GetFullPath(Path.Combine(destDirFullPath, entry.FullName));

            if (!completeFileName.StartsWith(destDirFullPath, StringComparison.OrdinalIgnoreCase))
            {
                throw new IOException("Zip Slip vulnerability detected: Entry tries to write outside target directory.");
            }

            var directory = Path.GetDirectoryName(completeFileName);
            if (!string.IsNullOrEmpty(directory))
                Directory.CreateDirectory(directory);

            entry.ExtractToFile(completeFileName, overwrite: true);
        }
    }

    private static string FindMakeCommand(BuildConfiguration? config)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return "make";

        if (config?.SelectedCompiler?.Path != null)
        {
            var compilerPath = new DirectoryInfo(config.SelectedCompiler.Path);
            var msys2Root = compilerPath.Parent?.Parent;
            
            if (msys2Root != null && msys2Root.Exists)
            {
                var makePaths = new[]
                {
                    Path.Combine(msys2Root.FullName, "usr", "bin", "make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "mingw32-make.exe")
                };

                foreach (var makePath in makePaths)
                {
                    if (File.Exists(makePath))
                        return makePath;
                }
            }
        }

        var commonMsys2Paths = new[]
        {
            @"C:\msys64",
            @"C:\msys2",
            @"D:\msys64",
            @"D:\msys2"
        };

        foreach (var msys2Path in commonMsys2Paths)
        {
            var makePaths = new[]
            {
                Path.Combine(msys2Path, "usr", "bin", "make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "mingw32-make.exe")
            };

            foreach (var makePath in makePaths)
            {
                if (File.Exists(makePath))
                    return makePath;
            }
        }

        return "make";
    }

    private static Dictionary<string, string> PrepareEnvironment(BuildConfiguration? config)
    {
        var env = new Dictionary<string, string>();
        foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
        {
            if (entry.Key != null && entry.Value != null)
                env[entry.Key.ToString()!] = entry.Value.ToString()!;
        }

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            var pathsToAdd = new List<string>();

            if (config?.SelectedCompiler?.Path != null)
            {
                var compilerPath = new DirectoryInfo(config.SelectedCompiler.Path);
                var msys2Root = compilerPath.Parent?.Parent;
                
                if (msys2Root != null && msys2Root.Exists)
                {
                    var usrBin = Path.Combine(msys2Root.FullName, "usr", "bin");
                    var mingw64Bin = Path.Combine(msys2Root.FullName, "mingw64", "bin");
                    
                    if (Directory.Exists(usrBin))
                        pathsToAdd.Add(usrBin);
                    if (Directory.Exists(mingw64Bin))
                        pathsToAdd.Add(mingw64Bin);
                }
            }
            else
            {
                var commonMsys2Paths = new[]
                {
                    @"C:\msys64",
                    @"C:\msys2",
                    @"D:\msys64",
                    @"D:\msys2"
                };

                foreach (var msys2Path in commonMsys2Paths)
                {
                    if (Directory.Exists(msys2Path))
                    {
                        var usrBin = Path.Combine(msys2Path, "usr", "bin");
                        var mingw64Bin = Path.Combine(msys2Path, "mingw64", "bin");
                        
                        if (Directory.Exists(usrBin))
                            pathsToAdd.Add(usrBin);
                        if (Directory.Exists(mingw64Bin))
                            pathsToAdd.Add(mingw64Bin);
                            
                        break;
                    }
                }
            }

            if (pathsToAdd.Count > 0)
            {
                var currentPath = env.GetValueOrDefault("PATH", string.Empty);
                env["PATH"] = string.Join(";", pathsToAdd) + ";" + currentPath;
            }
        }

        return env;
    }

    private static List<string> DetectNetworkFileNames(string sourceDirectory)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var candidates = new[]
        {
            Path.Combine(sourceDirectory, "evaluate.h"),
            Path.Combine(sourceDirectory, "nnue", "evaluate.h")
        };

        foreach (var candidate in candidates)
        {
            if (!File.Exists(candidate))
                continue;

            var contents = File.ReadAllText(candidate);
            foreach (Match match in NetworkMacroRegex.Matches(contents))
            {
                if (match.Success)
                    names.Add(match.Groups[1].Value);
            }
        }

        return names.ToList();
    }

    private static bool ValidateNetworkBytes(byte[] bytes, string fileName)
    {
        if (bytes.Length < 1_000_000)
            return false;

        var match = NetworkFileNameRegex.Match(fileName);
        if (!match.Success)
            return true;

        var expectedPrefix = match.Groups[1].Value.ToLowerInvariant();
        using var sha256 = SHA256.Create();
        var hash = Convert.ToHexString(sha256.ComputeHash(bytes)).ToLowerInvariant();
        return hash.StartsWith(expectedPrefix, StringComparison.Ordinal);
    }

    private void EnsureUserAgent()
    {
        if (_httpClient.DefaultRequestHeaders.UserAgent.Count == 0)
            _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("StockfishCompiler/1.0");
    }
}

==== END FILE: Services\StockfishDownloader.cs ====

==== BEGIN FILE: Services\CompilerInstallerService.cs (D:\GitHub\StockfishCompiler\Services\CompilerInstallerService.cs) ====
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using Microsoft.Extensions.Logging;

namespace StockfishCompiler.Services;

public interface ICompilerInstallerService
{
    Task<bool> IsMSYS2InstalledAsync();
    Task<(bool Success, string InstallPath)> InstallMSYS2Async(IProgress<string>? progress = null);
    Task<bool> InstallMSYS2PackagesAsync(string msys2Path, IProgress<string>? progress = null);
    Task<string> GetRecommendedInstallPathAsync();
}

public class CompilerInstallerService(ILogger<CompilerInstallerService> logger, HttpClient httpClient) : ICompilerInstallerService
{
    private const string MSYS2_INSTALLER_URL = "https://github.com/msys2/msys2-installer/releases/latest/download/msys2-x86_64-latest.exe";
    private const string DEFAULT_INSTALL_PATH = @"C:\msys64";
    
    public Task<bool> IsMSYS2InstalledAsync()
    {
        var commonPaths = new[]
        {
            @"C:\msys64",
            @"C:\msys2",
            @"D:\msys64",
            @"D:\msys2",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys64")
        };

        return Task.FromResult(commonPaths.Any(Directory.Exists));
    }

    public Task<string> GetRecommendedInstallPathAsync()
    {
        // Check which drive has more space
        var drives = DriveInfo.GetDrives()
            .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
            .OrderByDescending(d => d.AvailableFreeSpace)
            .ToList();

        foreach (var drive in drives)
        {
            var path = Path.Combine(drive.Name, "msys64");
            if (!Directory.Exists(path))
            {
                return Task.FromResult(path);
            }
        }

        return Task.FromResult(DEFAULT_INSTALL_PATH);
    }

    public async Task<(bool Success, string InstallPath)> InstallMSYS2Async(IProgress<string>? progress = null)
    {
        try
        {
            progress?.Report("Checking for existing MSYS2 installation...");
            
            if (await IsMSYS2InstalledAsync())
            {
                logger.LogInformation("MSYS2 already installed");
                progress?.Report("MSYS2 is already installed on your system.");
                return (true, DEFAULT_INSTALL_PATH);
            }

            var installPath = await GetRecommendedInstallPathAsync();
            progress?.Report($"Installing MSYS2 to {installPath}...");

            // Download the installer
            var tempPath = Path.Combine(Path.GetTempPath(), "msys2-installer.exe");
            
            progress?.Report("Downloading MSYS2 installer...");
            logger.LogInformation("Downloading MSYS2 from {Url}", MSYS2_INSTALLER_URL);

            using (var response = await httpClient.GetAsync(MSYS2_INSTALLER_URL, HttpCompletionOption.ResponseHeadersRead))
            {
                response.EnsureSuccessStatusCode();
                using var stream = await response.Content.ReadAsStreamAsync();
                using var fileStream = new FileStream(tempPath, FileMode.Create, FileAccess.Write, FileShare.None);
                
                await stream.CopyToAsync(fileStream);
            }

            progress?.Report("Download complete. Starting installation...");

            // Run the installer silently
            var installArgs = $"install --root {installPath} --confirm-command";
            
            var startInfo = new ProcessStartInfo
            {
                FileName = tempPath,
                Arguments = installArgs,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            using var process = Process.Start(startInfo);
            if (process == null)
            {
                logger.LogError("Failed to start MSYS2 installer");
                return (false, string.Empty);
            }

            await process.WaitForExitAsync();

            if (process.ExitCode != 0)
            {
                logger.LogError("MSYS2 installation failed with exit code {ExitCode}", process.ExitCode);
                progress?.Report("Installation failed. Please try installing MSYS2 manually.");
                return (false, string.Empty);
            }

            // Clean up temp file
            try { File.Delete(tempPath); } catch { }

            progress?.Report("MSYS2 installed successfully!");
            
            // Install required packages
            progress?.Report("Installing C++ compilers...");
            await InstallMSYS2PackagesAsync(installPath, progress);

            return (true, installPath);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to install MSYS2");
            progress?.Report($"Installation error: {ex.Message}");
            return (false, string.Empty);
        }
    }

    public async Task<bool> InstallMSYS2PackagesAsync(string msys2Path, IProgress<string>? progress = null)
    {
        try
        {
            // First, update the package database
            progress?.Report("Updating MSYS2 package database...");
            
            var bashPath = Path.Combine(msys2Path, "usr", "bin", "bash.exe");
            if (!File.Exists(bashPath))
            {
                logger.LogError("bash.exe not found at {Path}", bashPath);
                return false;
            }

            // Commands to run
            var commands = new[]
            {
                ("Updating core packages...", "-c \"pacman -Syu --noconfirm\""),
                ("Installing MinGW-w64 GCC compiler...", "-c \"pacman -S --noconfirm --needed mingw-w64-x86_64-gcc\""),
                ("Installing build tools...", "-c \"pacman -S --noconfirm --needed mingw-w64-x86_64-make mingw-w64-x86_64-toolchain\""),
                ("Installing Clang compiler (optional)...", "-c \"pacman -S --noconfirm --needed mingw-w64-clang-x86_64-clang\"")
            };

            foreach (var (message, command) in commands)
            {
                progress?.Report(message);
                
                var startInfo = new ProcessStartInfo
                {
                    FileName = bashPath,
                    Arguments = command,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    WorkingDirectory = msys2Path,
                    EnvironmentVariables =
                    {
                        ["MSYSTEM"] = "MINGW64",
                        ["PATH"] = $"{Path.Combine(msys2Path, "mingw64", "bin")};{Path.Combine(msys2Path, "usr", "bin")}"
                    }
                };

                using var process = Process.Start(startInfo);
                if (process == null) continue;

                await process.WaitForExitAsync();
                
                if (process.ExitCode != 0)
                {
                    logger.LogWarning("Package installation command failed: {Command}", command);
                    // Continue anyway, some packages might be optional
                }
            }

            progress?.Report("Compiler installation complete!");
            return true;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to install MSYS2 packages");
            progress?.Report($"Package installation error: {ex.Message}");
            return false;
        }
    }
}
==== END FILE: Services\CompilerInstallerService.cs ====

==== BEGIN FILE: Converters\ValueConverters.cs (D:\GitHub\StockfishCompiler\Converters\ValueConverters.cs) ====
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace StockfishCompiler.Converters;

public class InverseBooleanConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
            return !boolValue;
        return true;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
            return !boolValue;
        return false;
    }
}

public class NullToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return value == null ? Visibility.Collapsed : Visibility.Visible;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

==== END FILE: Converters\ValueConverters.cs ====

==== BEGIN FILE: Resources\DarkTheme.xaml (D:\GitHub\StockfishCompiler\Resources\DarkTheme.xaml) ====
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:StockfishCompiler.Converters">
    <!-- Colors -->
    <Color x:Key="PrimaryColor">#2D3748</Color>
    <Color x:Key="SecondaryColor">#1A202C</Color>
    <Color x:Key="AccentColor">#4299E1</Color>
    <Color x:Key="SuccessColor">#48BB78</Color>
    <Color x:Key="WarningColor">#ED8936</Color>
    <Color x:Key="ErrorColor">#F56565</Color>

    <Color x:Key="TextPrimaryColor">#F7FAFC</Color>
    <Color x:Key="TextSecondaryColor">#A0AEC0</Color>
    <Color x:Key="BorderColor">#4A5568</Color>

    <!-- Brushes -->
    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="{StaticResource SecondaryColor}"/>
    <SolidColorBrush x:Key="AccentBrush" Color="{StaticResource AccentColor}"/>
    <SolidColorBrush x:Key="SuccessBrush" Color="{StaticResource SuccessColor}"/>
    <SolidColorBrush x:Key="WarningBrush" Color="{StaticResource WarningColor}"/>
    <SolidColorBrush x:Key="ErrorBrush" Color="{StaticResource ErrorColor}"/>

    <SolidColorBrush x:Key="TextPrimaryBrush" Color="{StaticResource TextPrimaryColor}"/>
    <SolidColorBrush x:Key="TextSecondaryBrush" Color="{StaticResource TextSecondaryColor}"/>
    <SolidColorBrush x:Key="BorderBrush" Color="{StaticResource BorderColor}"/>

    <!-- Converters -->
    <local:InverseBooleanConverter x:Key="InverseBooleanConverter"/>
    <local:NullToVisibilityConverter x:Key="NullToVisibilityConverter"/>
    <BooleanToVisibilityConverter x:Key="BoolToVisibilityConverter"/>

    <!-- Control Styles -->
    <Style x:Key="DarkButton" TargetType="Button">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="15,8"/>
        <Setter Property="Margin" Value="5"/>
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Opacity" Value="0.5"/>
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style x:Key="DarkTabControl" TargetType="TabControl">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="0"/>
    </Style>

    <Style x:Key="DarkTabItem" TargetType="TabItem">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="TabItem">
                    <Border Name="Border" Background="{TemplateBinding Background}" 
                            BorderBrush="{TemplateBinding BorderBrush}" 
                            BorderThickness="1,1,1,0" 
                            CornerRadius="4,4,0,0" 
                            Margin="2,0,2,0" 
                            Padding="12,8">
                        <ContentPresenter x:Name="ContentSite" 
                                          VerticalAlignment="Center" 
                                          HorizontalAlignment="Center" 
                                          ContentSource="Header"/>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource SecondaryBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsSelected" Value="False">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource PrimaryBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource AccentBrush}"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="DarkTextBox" TargetType="TextBox">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="8"/>
        <Setter Property="CaretBrush" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Improved ComboBox with dark dropdown -->
    <Style x:Key="DarkComboBox" TargetType="ComboBox">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="8,6"/>
        <Setter Property="ItemContainerStyle">
            <Setter.Value>
                <Style TargetType="ComboBoxItem">
                    <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
                    <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                    <Setter Property="Padding" Value="8,6"/>
                    <Style.Triggers>
                        <Trigger Property="IsHighlighted" Value="True">
                            <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="ComboBox">
                    <Grid>
                        <ToggleButton x:Name="ToggleButton" 
                                      Background="{TemplateBinding Background}"
                                      BorderBrush="{TemplateBinding BorderBrush}"
                                      BorderThickness="{TemplateBinding BorderThickness}"
                                      Foreground="{TemplateBinding Foreground}"
                                      Focusable="False"
                                      IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                      ClickMode="Press">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition/>
                                    <ColumnDefinition Width="20"/>
                                </Grid.ColumnDefinitions>
                                <ContentPresenter Grid.Column="0" Margin="8,6" Content="{TemplateBinding SelectionBoxItem}" 
                                                  ContentTemplate="{TemplateBinding SelectionBoxItemTemplate}"
                                                  VerticalAlignment="Center" HorizontalAlignment="Left"/>
                                <Path Grid.Column="1" Data="M 0 0 L 4 4 L 8 0 Z" Fill="{StaticResource TextPrimaryBrush}" 
                                      VerticalAlignment="Center" HorizontalAlignment="Center"/>
                            </Grid>
                        </ToggleButton>
                        <Popup x:Name="Popup" Placement="Bottom" IsOpen="{TemplateBinding IsDropDownOpen}" 
                               AllowsTransparency="True" Focusable="False" PopupAnimation="Slide">
                            <Border Background="{StaticResource PrimaryBrush}" BorderBrush="{StaticResource BorderBrush}" 
                                    BorderThickness="1" SnapsToDevicePixels="True">
                                <ScrollViewer SnapsToDevicePixels="True">
                                    <StackPanel IsItemsHost="True" KeyboardNavigation.DirectionalNavigation="Contained"/>
                                </ScrollViewer>
                            </Border>
                        </Popup>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="DarkCheckBox" TargetType="CheckBox">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DarkRadioButton" TargetType="RadioButton">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DarkGroupBox" TargetType="GroupBox">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Margin" Value="0,10,0,0"/>
        <Setter Property="Padding" Value="10"/>
    </Style>

    <Style x:Key="InfoText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
    </Style>

    <Style x:Key="LabelText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        <Setter Property="Margin" Value="0,0,8,0"/>
    </Style>

    <Style x:Key="ValueText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DescriptionText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
        <Setter Property="TextWrapping" Value="Wrap"/>
    </Style>

    <Style x:Key="DarkProgressBar" TargetType="ProgressBar">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource AccentBrush}"/>
    </Style>

    <!-- StatusBar styling -->
    <Style TargetType="StatusBar">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style TargetType="StatusBarItem">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Dark ScrollBar / ScrollViewer Styles -->
    <Style TargetType="ScrollViewer">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Thumb with rounded dark appearance -->
    <Style x:Key="DarkScrollBarThumb" TargetType="Thumb">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Thumb">
                    <Border Background="{TemplateBinding Background}" BorderBrush="{StaticResource BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" CornerRadius="4"/>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
            <Trigger Property="IsDragging" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="ScrollBar">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="ScrollBar">
                    <Grid Background="{TemplateBinding Background}">
                        <Track x:Name="PART_Track" Orientation="{TemplateBinding Orientation}" Focusable="False">
                            <Track.Thumb>
                                <Thumb Style="{StaticResource DarkScrollBarThumb}"/>
                            </Track.Thumb>
                        </Track>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="Orientation" Value="Horizontal">
                            <Setter TargetName="PART_Track" Property="IsDirectionReversed" Value="False"/>
                            <Setter TargetName="PART_Track" Property="Height" Value="10"/>
                        </Trigger>
                        <Trigger Property="Orientation" Value="Vertical">
                            <Setter TargetName="PART_Track" Property="IsDirectionReversed" Value="True"/>
                            <Setter TargetName="PART_Track" Property="Width" Value="10"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>

==== END FILE: Resources\DarkTheme.xaml ====

==== BEGIN FILE: README.md (D:\GitHub\StockfishCompiler\README.md) ====
# StockfishCompiler

A WPF application for compiling Stockfish chess engine with automatic CPU architecture detection.

## Features

- Automatic compiler detection (MSYS2, MinGW, Clang)
- CPU architecture detection for optimal performance
- Download Stockfish source (stable or development)
- Profile-guided optimization build
- Real-time build output and progress
- Dark-themed UI

## Requirements

- Windows 10/11 with .NET 8 Runtime
- MSYS2 with MinGW-w64 or Clang installed

## Installation

### Install MSYS2

1. Download and install MSYS2 from https://www.msys2.org/
2. Open MSYS2 MSYS terminal and run:
   ```bash
   pacman -Syu
   pacman -S mingw-w64-x86_64-gcc make
   ```

### Run StockfishCompiler

1. Extract the release to a folder
2. Run `StockfishCompiler.exe`

## Usage

1. **Compiler Setup Tab**
   - Click "Detect Compilers" to find installed compilers
   - Click "Detect Optimal Architecture" to auto-select best CPU architecture

2. **Build Configuration Tab**
   - Adjust parallel jobs (defaults to your CPU core count)
   - Set output directory where compiled Stockfish will be saved
   - Choose build options (download network, strip executable)

3. **Compilation Tab**
   - Click "Start Build" to begin compilation
   - View real-time build output
   - Cancel build if needed

## Troubleshooting

### Application won't start

Check logs at: `%LOCALAPPDATA%\StockfishCompiler\logs\`

Or run `OpenLogs.bat` (included in release) to open the logs folder.

### No compilers found

Make sure MSYS2 is installed and MinGW-w64 toolchain is installed:
```bash
pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-make
```

### Build fails

- Ensure `make` is available in MSYS2 (`C:\msys64\usr\bin\make.exe`)
- Check that compiler path is correct in Compiler Setup tab
- Review build output in Compilation tab for specific errors

## Logs

Application logs are saved to:
```
%LOCALAPPDATA%\StockfishCompiler\logs\app-YYYY-MM-DD.log
```

Use `OpenLogs.bat` to quickly open the logs folder.

## License

MIT License - see LICENSE file for details

## Credits

- Stockfish: https://github.com/official-stockfish/Stockfish
- UI Framework: WPF (.NET 8)
- MVVM Toolkit: CommunityToolkit.Mvvm
- Logging: Serilog

==== END FILE: README.md ====

==== BEGIN FILE: TROUBLESHOOTING.md (D:\GitHub\StockfishCompiler\TROUBLESHOOTING.md) ====
# Troubleshooting Fixed ?

## Problem
Application wouldn't start after publish - no visible error, just silent failure.

## Root Causes Found

### 1. Resource Loading Issue
**Problem**: `DarkTheme.xaml` resources weren't accessible to views.
**Error in logs**: `Cannot find resource named 'DarkGroupBox'`
**Fix**: Moved resource dictionary to `App.xaml` as merged dictionary instead of window-level resource.

### 2. Single-File Publish Issues
**Problem**: WPF applications don't always work well with PublishSingleFile=true due to resource loading.
**Fix**: Changed to framework-dependent deployment with separate DLLs.

## Solutions Implemented

### 1. Added Comprehensive Logging (Serilog)
- **Location**: `%LOCALAPPDATA%\StockfishCompiler\logs\app-YYYY-MM-DD.log`
- **Features**:
  - Logs all application startup steps
  - Logs service initialization
  - Logs all user actions (detect compilers, build, etc.)
  - Catches and logs all exceptions
  - Shows log file location in error dialogs

### 2. Fixed Resource Loading
**Before** (MainWindow.xaml):
```xml
<Window.Resources>
    <ResourceDictionary Source="Resources/DarkTheme.xaml"/>
</Window.Resources>
```

**After** (App.xaml):
```xml
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Resources/DarkTheme.xaml"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>
```

### 3. Changed Publish Configuration
**Before** (.csproj):
```xml
<!-- Single-file, self-contained -->
<PublishSingleFile>true</PublishSingleFile>
<SelfContained>true</SelfContained>
```

**After** (.csproj):
```xml
<!-- Framework-dependent with DLLs -->
<PublishSingleFile>false</PublishSingleFile>
<SelfContained>false</SelfContained>
```

### 4. Added Troubleshooting Tools

#### A. In-App Log Access
- Added "Open Log Folder" button in the app footer
- Instantly opens logs directory in Windows Explorer

#### B. OpenLogs.bat
```batch
explorer "%LOCALAPPDATA%\StockfishCompiler\logs"
```
Standalone batch file to open logs without running the app.

#### C. BuildRelease.bat
Automated script that:
1. Kills running instances
2. Cleans old builds
3. Publishes release build
4. Copies files to `Release\` folder
5. Includes README and OpenLogs.bat

### 5. Error Handling Improvements
```csharp
// Global exception handler in App.xaml.cs
private void Application_DispatcherUnhandledException(...)
{
    Log.Error(e.Exception, "Unhandled exception");
    MessageBox.Show($"Error: {ex.Message}\n\nCheck logs for details.");
    e.Handled = true;
}
```

## How to Diagnose Future Issues

### 1. Check Logs First
```
%LOCALAPPDATA%\StockfishCompiler\logs\app-YYYY-MM-DD.log
```
Or run `OpenLogs.bat` or click "Open Log Folder" button in app.

### 2. Look for Error Patterns
- **XamlParseException**: Resource loading issue
- **FileNotFoundException**: Missing DLL or file
- **TypeLoadException**: Assembly version mismatch
- **InvalidOperationException**: DI configuration issue

### 3. Test in Debug Mode
```powershell
dotnet run
```
Will show immediate errors in console.

### 4. Build and Run
```powershell
.\BuildRelease.bat
```
Creates clean release build and shows any build errors.

## Deployment Checklist

? Framework-dependent (requires .NET 8 Desktop Runtime on target PC)
? All DLLs included in publish folder
? Resources properly loaded as application-level merged dictionaries
? Comprehensive logging enabled
? Error dialogs show log file location
? In-app log access via button
? README.md with troubleshooting guide
? BuildRelease.bat for easy packaging

## Log Output Example (Successful Start)

```
2025-11-18 11:35:09.512 [INF] Application starting...
2025-11-18 11:35:09.250 [INF] Log file: C:\Users\...\logs\app-2025-11-18.log
2025-11-18 11:35:09.619 [INF] Services configured successfully
2025-11-18 11:35:09.843 [INF] MainViewModel initializing
2025-11-18 11:35:09.844 [INF] Loading available architectures
2025-11-18 11:35:09.849 [INF] Loaded 8 architectures
2025-11-18 11:35:09.849 [INF] MainViewModel initialized
2025-11-18 11:35:09.850 [INF] BuildViewModel initializing
2025-11-18 11:35:09.864 [INF] BuildViewModel initialized
2025-11-18 11:35:09.870 [INF] MainWindow created, showing...
2025-11-18 11:35:09.978 [INF] Application startup complete
```

## Requirements for End Users

**Required**:
- Windows 10/11
- .NET 8 Desktop Runtime: https://dotnet.microsoft.com/download/dotnet/8.0
- MSYS2 with MinGW-w64 (for building Stockfish)

**Installation**:
1. Extract ZIP to any folder
2. Run `StockfishCompiler.exe`
3. If errors occur, click "Open Log Folder" button or run `OpenLogs.bat`

## Build Commands

### Development
```powershell
dotnet run
```

### Release Build
```powershell
.\BuildRelease.bat
```

Or manually:
```powershell
dotnet publish -c Release -r win-x64
```

Output: `bin\Release\net8.0-windows\win-x64\publish\`

==== END FILE: TROUBLESHOOTING.md ====

==== BEGIN FILE: BuildRelease.bat (D:\GitHub\StockfishCompiler\BuildRelease.bat) ====
@echo off
echo =============================================
echo StockfishCompiler - Build Release Package
echo =============================================
echo.

echo Stopping any running instances...
taskkill /IM StockfishCompiler.exe /F >nul 2>&1

echo.
echo Cleaning previous builds...
rmdir /s /q bin obj publish 2>nul

echo.
echo Building Release...
dotnet publish -c Release -r win-x64

if %ERRORLEVEL% NEQ 0 (
    echo.
    echo Build FAILED!
    pause
    exit /b 1
)

echo.
echo Copying files to release folder...
if not exist "Release" mkdir Release
xcopy /E /I /Y "bin\Release\net8.0-windows\win-x64\publish\*" "Release\"
copy /Y "OpenLogs.bat" "Release\"
copy /Y "README.md" "Release\"

echo.
echo =============================================
echo SUCCESS! Release package created in Release\ folder
echo =============================================
echo.
echo Files:
dir /B Release

echo.
echo Run Release\StockfishCompiler.exe to test
pause

==== END FILE: BuildRelease.bat ====

==== BEGIN FILE: OpenLogs.bat (D:\GitHub\StockfishCompiler\OpenLogs.bat) ====
@echo off
echo Opening StockfishCompiler logs directory...
set LOGDIR=%LOCALAPPDATA%\StockfishCompiler\logs
if not exist "%LOGDIR%" (
    echo No logs directory found yet. Run the application first.
    pause
    exit /b
)
explorer "%LOGDIR%"

==== END FILE: OpenLogs.bat ====

