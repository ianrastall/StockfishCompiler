
==== BEGIN FILE: StockfishCompiler.csproj (D:\GitHub\StockfishCompiler\StockfishCompiler.csproj) ====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
    <SelfContained>false</SelfContained>
    <PublishSingleFile>false</PublishSingleFile>
    <ApplicationIcon>App.ico</ApplicationIcon>
    <Version>1.3.0</Version>
    <AssemblyVersion>1.3.0.0</AssemblyVersion>
    <FileVersion>1.3.0.0</FileVersion>
  </PropertyGroup>

  <ItemGroup>
    <Resource Include="App.ico" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.3.2" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.0" />
    <PackageReference Include="Serilog" Version="4.2.0" />
    <PackageReference Include="Serilog.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    <PackageReference Include="System.Reactive" Version="6.0.0" />
  </ItemGroup>

</Project>

==== END FILE: StockfishCompiler.csproj ====

==== BEGIN FILE: App.xaml (D:\GitHub\StockfishCompiler\App.xaml) ====
<Application x:Class="StockfishCompiler.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             DispatcherUnhandledException="Application_DispatcherUnhandledException">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Resources/DarkTheme.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>

==== END FILE: App.xaml ====

==== BEGIN FILE: App.xaml.cs (D:\GitHub\StockfishCompiler\App.xaml.cs) ====
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Serilog;
using System.IO;
using System.Net.Http;
using System.Windows;
using StockfishCompiler.Services;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        public static ServiceProvider Services { get; private set; } = null!;

        protected override void OnStartup(StartupEventArgs e)
        {
            // Set up logging first
            var logPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "StockfishCompiler",
                "logs",
                $"app-{DateTime.Now:yyyy-MM-dd}.log"
            );

            Directory.CreateDirectory(Path.GetDirectoryName(logPath)!);

            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            Log.Information("Application starting...");
            Log.Information("Log file: {LogPath}", logPath);

            try
            {
                CleanupStaleTempDirectories();

                base.OnStartup(e);

                var services = new ServiceCollection();

                // Logging
                services.AddLogging(builder =>
                {
                    builder.AddSerilog();
                    builder.SetMinimumLevel(LogLevel.Debug);
                });

                // Configure HttpClient properly with timeout and user agent
                services.AddHttpClient<IStockfishDownloader, StockfishDownloader>(client =>
                {
                    client.Timeout = TimeSpan.FromMinutes(10);
                    client.DefaultRequestHeaders.UserAgent.ParseAdd("StockfishCompiler/1.0");
                });

                // Services
                services.AddSingleton<ICompilerService, CompilerService>();
                services.AddSingleton<ICompilerInstallerService, CompilerInstallerService>();
                services.AddSingleton<IArchitectureDetector, ArchitectureDetector>();
                services.AddSingleton<IBuildService, BuildService>(); // Singleton to match BuildViewModel lifetime
                services.AddSingleton<IUserSettingsService, UserSettingsService>();

                // ViewModels
                services.AddSingleton<MainViewModel>();
                services.AddSingleton<BuildViewModel>(); // Singleton to preserve state when switching tabs

                Services = services.BuildServiceProvider();

                Log.Information("Services configured successfully");

                var window = new MainWindow
                {
                    DataContext = Services.GetRequiredService<MainViewModel>()
                };

                Log.Information("MainWindow created, showing...");
                window.Show();
                Log.Information("Application startup complete");
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, "Application failed to start");
                MessageBox.Show(
                    $"Application failed to start:\n\n{ex.Message}\n\nLog file: {logPath}",
                    "Startup Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error
                );
                Log.CloseAndFlush();
                Shutdown(1);
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Log.Information("Application exiting with code {ExitCode}", e.ApplicationExitCode);
            Services?.Dispose();
            Log.CloseAndFlush();
            base.OnExit(e);
        }

        private void Application_DispatcherUnhandledException(object sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs e)
        {
            Log.Error(e.Exception, "Unhandled exception occurred");
            MessageBox.Show(
                $"An unexpected error occurred:\n\n{e.Exception.Message}\n\nCheck logs for details.",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error
            );
            e.Handled = true;
        }

        private static void CleanupStaleTempDirectories()
        {
            var tempPath = Path.GetTempPath();
            var cutoff = DateTime.UtcNow - TimeSpan.FromHours(24);
            var patterns = new[] { "stockfish_build_*", "sf_prof_*" };

            foreach (var pattern in patterns)
            {
                foreach (var dir in Directory.GetDirectories(tempPath, pattern))
                {
                    try
                    {
                        var info = new DirectoryInfo(dir);
                        var lastWrite = info.LastWriteTimeUtc;
                        if (lastWrite < cutoff)
                        {
                            info.Delete(true);
                            Log.Information("Removed stale temp directory {TempDir}", dir);
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Warning(ex, "Failed to remove stale temp directory {TempDir}", dir);
                    }
                }
            }
        }
    }
}

==== END FILE: App.xaml.cs ====

==== BEGIN FILE: MainWindow.xaml (D:\GitHub\StockfishCompiler\MainWindow.xaml) ====
<Window x:Class="StockfishCompiler.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:views="clr-namespace:StockfishCompiler.Views"
        mc:Ignorable="d"
        Title="Stockfish Compiler" Height="750" Width="950" WindowStartupLocation="CenterScreen" Icon="App.ico">

    <Grid Background="{StaticResource SecondaryBrush}">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <Border Grid.Row="0" Background="{StaticResource PrimaryBrush}" Padding="20,15" BorderBrush="{StaticResource BorderBrush}" BorderThickness="0,0,0,1">
            <TextBlock Text="Stockfish Compiler" FontSize="24" FontWeight="Bold" Foreground="{StaticResource TextPrimaryBrush}"/>
        </Border>

        <TabControl Grid.Row="1" Style="{StaticResource DarkTabControl}">
            <TabItem Header="Compiler Setup" Style="{StaticResource DarkTabItem}">
                <views:CompilerSelectionView/>
            </TabItem>
            <TabItem Header="Build Configuration" Style="{StaticResource DarkTabItem}">
                <views:BuildConfigurationView/>
            </TabItem>
            <TabItem Header="Compilation" Style="{StaticResource DarkTabItem}">
                <views:BuildProgressView/>
            </TabItem>
        </TabControl>

        <StatusBar Grid.Row="2" Background="{StaticResource SecondaryBrush}">
            <StatusBarItem>
                <TextBlock Text="{Binding StatusMessage}"/>
            </StatusBarItem>
            <StatusBarItem HorizontalAlignment="Right">
                <TextBlock Text="{Binding SystemInfo}"/>
            </StatusBarItem>
        </StatusBar>

        <Border Grid.Row="3" Background="{StaticResource PrimaryBrush}" Padding="10,5" BorderBrush="{StaticResource BorderBrush}" BorderThickness="0,1,0,0">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <TextBlock Text="Build Output:" Foreground="{StaticResource TextSecondaryBrush}" VerticalAlignment="Center" Margin="0,0,6,0"/>
                <Button Content="Copy Output" Click="CopyBuildOutput_Click" Style="{StaticResource DarkButton}" Padding="10,4" Margin="0,0,10,0"/>
                <Rectangle Width="1" Fill="{StaticResource BorderBrush}" Height="18" VerticalAlignment="Center" Margin="0,0,10,0"/>
                <TextBlock Text="Logs:" Foreground="{StaticResource TextSecondaryBrush}" VerticalAlignment="Center" Margin="0,0,6,0"/>
                <Button Content="Open Log Folder" Click="OpenLogsFolder_Click" Style="{StaticResource DarkButton}" Padding="10,4"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>

==== END FILE: MainWindow.xaml ====

==== BEGIN FILE: MainWindow.xaml.cs (D:\GitHub\StockfishCompiler\MainWindow.xaml.cs) ====
using System;
using System.Diagnostics;
using System.IO;
using System.Windows;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void OpenLogsFolder_Click(object sender, RoutedEventArgs e)
        {
            var logPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "StockfishCompiler",
                "logs"
            );

            if (Directory.Exists(logPath))
            {
                Process.Start("explorer.exe", logPath);
            }
            else
            {
                MessageBox.Show(
                    "No logs directory found yet. Logs will be created when the application runs.",
                    "Logs",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information
                );
            }
        }

        private void CopyBuildOutput_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var buildVm = App.Services?.GetService<BuildViewModel>();
                var output = buildVm?.BuildOutput;

                if (!string.IsNullOrWhiteSpace(output))
                {
                    Clipboard.SetText(output);
                    MessageBox.Show(
                        "Build output copied to clipboard.",
                        "Copy Output",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information
                    );
                }
                else
                {
                    MessageBox.Show(
                        "No build output available yet. Start a build first.",
                        "Copy Output",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information
                    );
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(
                    $"Failed to copy output:\n{ex.Message}",
                    "Copy Output",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error
                );
            }
        }
    }
}

==== END FILE: MainWindow.xaml.cs ====

==== BEGIN FILE: AssemblyInfo.cs (D:\GitHub\StockfishCompiler\AssemblyInfo.cs) ====
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]

==== END FILE: AssemblyInfo.cs ====

==== BEGIN FILE: Constants\CompilerConstants.cs (D:\GitHub\StockfishCompiler\Constants\CompilerConstants.cs) ====
namespace StockfishCompiler.Constants;

public static class CompilerType
{
    public const string GCC = "gcc";
    public const string Clang = "clang";
    public const string MSVC = "msvc";
    public const string MinGW = "mingw";
}

public static class BuildTargets
{
    public const string ProfileBuild = "profile-build";
    public const string Build = "build";
    public const string Strip = "strip";
    public const string ConfigSanity = "config-sanity";
    public const string Analyze = "analyze";
    public const string Net = "net";
}

public static class SourceVersions
{
    public const string Master = "master";
    public const string Stable = "stable";
}

public static class Architectures
{
    public const string X86_64 = "x86-64";
    public const string X86_64_VNNI512 = "x86-64-vnni512";
    public const string X86_64_VNNI256 = "x86-64-vnni256";
    public const string X86_64_AVX512 = "x86-64-avx512";
    public const string X86_64_BMI2 = "x86-64-bmi2";
    public const string X86_64_AVX2 = "x86-64-avx2";
    public const string X86_64_SSE41_POPCNT = "x86-64-sse41-popcnt";
    public const string X86_64_SSSE3 = "x86-64-ssse3";
    public const string X86_64_SSE3_POPCNT = "x86-64-sse3-popcnt";
    public const string ARMV8 = "armv8";
    public const string APPLE_SILICON = "apple-silicon";
}

==== END FILE: Constants\CompilerConstants.cs ====

==== BEGIN FILE: Views\BuildConfigurationView.xaml (D:\GitHub\StockfishCompiler\Views\BuildConfigurationView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.BuildConfigurationView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ScrollViewer>
        <StackPanel Margin="20">
            <GroupBox Header="Build Options" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <CheckBox Content="Download neural network (NNUE)" IsChecked="{Binding DownloadNetwork}" Style="{StaticResource DarkCheckBox}" Margin="0,5"/>
                    <CheckBox Content="Strip executable (reduce file size)" IsChecked="{Binding StripExecutable}" Style="{StaticResource DarkCheckBox}" Margin="0,5"/>
                    <CheckBox Content="Use PGO (profile-guided optimization)" IsChecked="{Binding EnablePgo}" Style="{StaticResource DarkCheckBox}" Margin="0,5"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,10,0,5">
                        <TextBlock Text="Parallel jobs:" Style="{StaticResource LabelText}" VerticalAlignment="Center"/>
                        <TextBox Width="60" Text="{Binding ParallelJobs}" Style="{StaticResource DarkTextBox}"/>
                        <TextBlock Text="(CPU cores)" Style="{StaticResource InfoText}" Margin="10,0" VerticalAlignment="Center"/>
                    </StackPanel>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Output Directory" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBox Text="{Binding OutputDirectory}" Style="{StaticResource DarkTextBox}" Margin="0,5"/>
                    <TextBlock Text="The compiled Stockfish executable will be saved here." Style="{StaticResource DescriptionText}" Margin="0,5,0,0"/>
                </StackPanel>
            </GroupBox>
        </StackPanel>
    </ScrollViewer>
</UserControl>

==== END FILE: Views\BuildConfigurationView.xaml ====

==== BEGIN FILE: Views\BuildConfigurationView.xaml.cs (D:\GitHub\StockfishCompiler\Views\BuildConfigurationView.xaml.cs) ====
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler.Views
{
    public partial class BuildConfigurationView : UserControl
    {
        public BuildConfigurationView()
        {
            InitializeComponent();
            
            if (App.Services != null)
            {
                var mainVm = App.Services.GetService<MainViewModel>();
                if (mainVm != null)
                {
                    DataContext = mainVm;
                }
            }
        }
    }
}

==== END FILE: Views\BuildConfigurationView.xaml.cs ====

==== BEGIN FILE: Views\BuildProgressView.xaml (D:\GitHub\StockfishCompiler\Views\BuildProgressView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.BuildProgressView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:helpers="clr-namespace:StockfishCompiler.Helpers">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <ProgressBar Grid.Row="0" Height="18" Value="{Binding BuildProgress}" Style="{StaticResource DarkProgressBar}" Margin="0,0,0,10"/>

        <TextBox Grid.Row="1"
                 Text="{Binding BuildOutput}"
                 Style="{StaticResource DarkTextBox}"
                 AcceptsReturn="True"
                 TextWrapping="Wrap"
                 IsReadOnly="True"
                 VerticalScrollBarVisibility="Auto"
                 Margin="0,0,0,10"
                 FontFamily="Consolas"
                 FontSize="11"
                 helpers:TextBoxHelper.AlwaysScrollToEnd="True"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right">
            <Button Content="Start Build" Command="{Binding StartBuildCommand}" Style="{StaticResource DarkButton}"/>
            <Button Content="Cancel" Command="{Binding CancelBuildCommand}" Style="{StaticResource DarkButton}"/>
        </StackPanel>
    </Grid>
</UserControl>

==== END FILE: Views\BuildProgressView.xaml ====

==== BEGIN FILE: Views\BuildProgressView.xaml.cs (D:\GitHub\StockfishCompiler\Views\BuildProgressView.xaml.cs) ====
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler.Views
{
    public partial class BuildProgressView : UserControl
    {
        public BuildProgressView()
        {
            InitializeComponent();
            // Safe runtime resolution; skip during design-time or before App.Services initialized
            if (App.Services != null)
            {
                var vm = App.Services.GetService<BuildViewModel>();
                if (vm != null)
                    DataContext = vm;
            }
        }
    }
}

==== END FILE: Views\BuildProgressView.xaml.cs ====

==== BEGIN FILE: Views\CompilerSelectionView.xaml (D:\GitHub\StockfishCompiler\Views\CompilerSelectionView.xaml) ====
<UserControl x:Class="StockfishCompiler.Views.CompilerSelectionView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ScrollViewer>
        <StackPanel Margin="20">
            <GroupBox Header="System Information" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="{Binding SystemInfo}" Style="{StaticResource InfoText}" Margin="0,5"/>
                    <StackPanel Orientation="Horizontal">
                        <Button Content="Detect Compilers" 
                                Command="{Binding DetectCompilersCommand}" 
                                Style="{StaticResource DarkButton}" 
                                HorizontalAlignment="Left"
                                IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                        <Button Content="Download &amp; Install MSYS2 (GCC)"
                                Click="InstallCompiler_Click"
                                Style="{StaticResource DarkButton}"
                                HorizontalAlignment="Left"
                                IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                    </StackPanel>
                    <TextBlock Text="If no compiler is found, use the installer to grab MSYS2 + GCC, then re-run detection."
                               Style="{StaticResource DescriptionText}"
                               Margin="0,5,0,0"/>
                    <TextBlock Text="Detecting compilers..." 
                               Style="{StaticResource InfoText}" 
                               Margin="10,5" 
                               Visibility="{Binding IsDetectingCompilers, Converter={StaticResource BoolToVisibilityConverter}}"/>
                    <TextBlock Text="{Binding DetectionDetails}"
                               Style="{StaticResource DescriptionText}"
                               Margin="0,5,0,0"
                               TextWrapping="Wrap"/>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Compiler Selection" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="Select a compiler from the dropdown:" 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,0,0,5"/>
                    
                    <ComboBox ItemsSource="{Binding AvailableCompilers}"
                              SelectedItem="{Binding SelectedCompiler}"
                              DisplayMemberPath="DisplayName"
                              Style="{StaticResource DarkComboBox}" 
                              Height="35" 
                              Margin="0,5"
                              IsEnabled="{Binding IsDetectingCompilers, Converter={StaticResource InverseBooleanConverter}}"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,10,0,5" Visibility="{Binding SelectedCompiler, Converter={StaticResource NullToVisibilityConverter}}">
                        <TextBlock Text="Compiler Path:" Style="{StaticResource LabelText}"/>
                        <TextBlock Text="{Binding SelectedCompiler.Path}" Style="{StaticResource ValueText}"/>
                    </StackPanel>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,5" Visibility="{Binding SelectedCompiler, Converter={StaticResource NullToVisibilityConverter}}">
                        <TextBlock Text="Version:" Style="{StaticResource LabelText}"/>
                        <TextBlock Text="{Binding SelectedCompiler.Version}" Style="{StaticResource ValueText}"/>
                    </StackPanel>
                </StackPanel>
            </GroupBox>

            <GroupBox Header="Architecture Selection" Style="{StaticResource DarkGroupBox}">
                <StackPanel>
                    <TextBlock Text="CPU architecture determines optimal instruction sets for performance." 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,0,0,10"/>
                    
                    <Button Content="Detect Optimal Architecture" 
                            Command="{Binding DetectArchitectureCommand}" 
                            Style="{StaticResource DarkButton}" 
                            HorizontalAlignment="Left"/>
                    
                    <TextBlock Text="Detecting CPU features..." 
                               Style="{StaticResource InfoText}" 
                               Margin="10,5" 
                               Visibility="{Binding IsDetectingArchitecture, Converter={StaticResource BoolToVisibilityConverter}}"/>
                    
                    <ComboBox ItemsSource="{Binding AvailableArchitectures}"
                              SelectedItem="{Binding SelectedArchitecture}"
                              DisplayMemberPath="Name"
                              Style="{StaticResource DarkComboBox}" 
                              Height="35" 
                              Margin="0,10,0,5"
                              IsEnabled="{Binding IsDetectingArchitecture, Converter={StaticResource InverseBooleanConverter}}"/>
                    
                    <TextBlock Text="{Binding SelectedArchitecture.Description}" 
                               Style="{StaticResource DescriptionText}" 
                               Margin="0,5,0,0"
                               Visibility="{Binding SelectedArchitecture, Converter={StaticResource NullToVisibilityConverter}}"/>
                </StackPanel>
            </GroupBox>
        </StackPanel>
    </ScrollViewer>
</UserControl>

==== END FILE: Views\CompilerSelectionView.xaml ====

==== BEGIN FILE: Views\CompilerSelectionView.xaml.cs (D:\GitHub\StockfishCompiler\Views\CompilerSelectionView.xaml.cs) ====
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.ViewModels;

namespace StockfishCompiler.Views
{
    public partial class CompilerSelectionView : UserControl
    {
        public CompilerSelectionView()
        {
            InitializeComponent();
            
            if (App.Services != null)
            {
                var mainVm = App.Services.GetService<MainViewModel>();
                if (mainVm != null)
                {
                    DataContext = mainVm;
                }
            }
        }

        private async void InstallCompiler_Click(object sender, RoutedEventArgs e)
        {
            var installerWindow = new CompilerInstallerWindow(App.Services)
            {
                Owner = Window.GetWindow(this)
            };

            var result = installerWindow.ShowDialog();
            if (result == true && installerWindow.CompilerInstalled && DataContext is MainViewModel vm)
            {
                vm.StatusMessage = "Re-running compiler detection after install...";
                await vm.DetectCompilersCommand.ExecuteAsync(null);
            }
        }
    }
}

==== END FILE: Views\CompilerSelectionView.xaml.cs ====

==== BEGIN FILE: Views\CompilerInstallerWindow.xaml (D:\GitHub\StockfishCompiler\Views\CompilerInstallerWindow.xaml) ====
<Window x:Class="StockfishCompiler.Views.CompilerInstallerWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Install C++ Compiler" 
        Height="400" 
        Width="600"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="{DynamicResource BackgroundBrush}">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" 
                   Text="No C++ Compiler Found" 
                   FontSize="24" 
                   FontWeight="Bold" 
                   Foreground="{DynamicResource ForegroundBrush}"
                   Margin="0,0,0,10"/>

        <TextBlock Grid.Row="1" 
                   TextWrapping="Wrap"
                   Foreground="{DynamicResource ForegroundMutedBrush}"
                   Margin="0,0,0,20">
            <Run Text="To compile Stockfish, you need a C++ compiler. "/>
            <Run Text="We can automatically install MSYS2 with GCC for you."/>
            <LineBreak/>
            <LineBreak/>
            <Run Text="This will:"/>
            <LineBreak/>
            <Run Text="- Download and install MSYS2 (~100 MB)"/>
            <LineBreak/>
            <Run Text="- Install the MinGW-w64 GCC compiler"/>
            <LineBreak/>
            <Run Text="- Configure everything automatically"/>
        </TextBlock>

        <ScrollViewer Grid.Row="2" 
                      VerticalScrollBarVisibility="Auto"
                      Margin="0,0,0,20">
            <TextBox x:Name="LogTextBox"
                     Style="{StaticResource DarkTextBox}"
                     IsReadOnly="True"
                     FontFamily="Consolas"
                     TextWrapping="Wrap"
                     AcceptsReturn="True"/>
        </ScrollViewer>

        <Grid Grid.Row="3">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <ProgressBar x:Name="InstallProgress"
                         Grid.Column="0"
                         Height="25"
                         Margin="0,0,10,0"
                         Style="{StaticResource DarkProgressBar}"
                         Visibility="Collapsed"/>

            <Button x:Name="InstallButton"
                    Grid.Column="1"
                    Content="Install Compiler"
                    Width="120"
                    Height="30"
                    Margin="0,0,10,0"
                    Style="{StaticResource DarkButton}"
                    Click="InstallButton_Click"/>

            <Button x:Name="CancelButton"
                    Grid.Column="2"
                    Content="Cancel"
                    Width="80"
                    Height="30"
                    Style="{StaticResource DarkButton}"
                    Click="CancelButton_Click"/>
        </Grid>
    </Grid>
</Window>

==== END FILE: Views\CompilerInstallerWindow.xaml ====

==== BEGIN FILE: Views\CompilerInstallerWindow.xaml.cs (D:\GitHub\StockfishCompiler\Views\CompilerInstallerWindow.xaml.cs) ====
using System;
using System.Threading.Tasks;
using System.Windows;
using Microsoft.Extensions.DependencyInjection;
using StockfishCompiler.Services;

namespace StockfishCompiler.Views;

public partial class CompilerInstallerWindow : Window
{
    private readonly ICompilerInstallerService _installerService;
    private CancellationTokenSource? _cts;
    private bool _isInstalling;

    public bool CompilerInstalled { get; private set; }
    public string? InstalledPath { get; private set; }

    public CompilerInstallerWindow(IServiceProvider serviceProvider)
    {
        InitializeComponent();
        _installerService = serviceProvider.GetRequiredService<ICompilerInstallerService>();
    }

    private async void InstallButton_Click(object sender, RoutedEventArgs e)
    {
        if (_isInstalling) return;

        _isInstalling = true;
        _cts = new CancellationTokenSource();
        InstallButton.IsEnabled = false;
        InstallProgress.Visibility = Visibility.Visible;
        LogTextBox.Clear();

        var progress = new Progress<string>(message =>
        {
            Dispatcher.Invoke(() =>
            {
                LogTextBox.AppendText($"{DateTime.Now:HH:mm:ss} - {message}\n");
                LogTextBox.ScrollToEnd();
            });
        });

        try
        {
            var (success, installPath) = await _installerService.InstallMSYS2Async(progress, _cts.Token);

            if (success)
            {
                CompilerInstalled = true;
                InstalledPath = installPath;
                
                MessageBox.Show(
                    "Compiler installed successfully!\n\n" +
                    $"Location: {installPath}\n\n" +
                    "Click OK to continue with compiler detection.",
                    "Installation Complete",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);
                
                DialogResult = true;
            }
            else
            {
                MessageBox.Show(
                    "Compiler installation failed.\n\n" +
                    "Please check the log for details or install MSYS2 manually.",
                    "Installation Failed",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
        }
        catch (Exception ex)
        {
            MessageBox.Show(
                $"An error occurred during installation:\n\n{ex.Message}",
                "Installation Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }
        finally
        {
            _isInstalling = false;
            _cts?.Dispose();
            _cts = null;
            InstallButton.IsEnabled = true;
            InstallProgress.Visibility = Visibility.Collapsed;
        }
    }

    private void CancelButton_Click(object sender, RoutedEventArgs e)
    {
        if (_isInstalling)
        {
            var result = MessageBox.Show(
                "Installation is in progress. Are you sure you want to cancel?",
                "Cancel Installation",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);
            
            if (result != MessageBoxResult.Yes) return;

            _cts?.Cancel();
        }

        DialogResult = false;
    }
}

==== END FILE: Views\CompilerInstallerWindow.xaml.cs ====

==== BEGIN FILE: ViewModels\MainViewModel.cs (D:\GitHub\StockfishCompiler\ViewModels\MainViewModel.cs) ====
using System.Collections.ObjectModel;
using System.IO;
using System.Runtime.InteropServices;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;
using StockfishCompiler.Services;
using StockfishCompiler.Helpers;

namespace StockfishCompiler.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly ICompilerService _compilerService;
    private readonly IArchitectureDetector _architectureDetector;
    private readonly ILogger<MainViewModel> _logger;
    private readonly IUserSettingsService _userSettingsService;
    private UserSettings _userSettings = new();
    private bool _isRestoringSettings;
    private bool _isAdjustingParallelJobs;

    public MainViewModel(
        ICompilerService compilerService, 
        IArchitectureDetector architectureDetector, 
        ILogger<MainViewModel> logger,
        IUserSettingsService userSettingsService)
    {
        _compilerService = compilerService;
        _architectureDetector = architectureDetector;
        _logger = logger;
        _userSettingsService = userSettingsService;

        _logger.LogInformation("MainViewModel initializing");

        DetectCompilersCommand = new AsyncRelayCommand(DetectCompilersAsync);
        DetectArchitectureCommand = new AsyncRelayCommand(DetectOptimalArchitectureAsync, () => SelectedCompiler != null);

        LoadUserSettings();
        _ = LoadAvailableArchitectures();
        
        _logger.LogInformation("MainViewModel initialized");
    }

    [ObservableProperty]
    private ObservableCollection<CompilerInfo> availableCompilers = [];

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(DetectArchitectureCommand))]
    private CompilerInfo? selectedCompiler;

    [ObservableProperty]
    private ObservableCollection<ArchitectureInfo> availableArchitectures = [];

    [ObservableProperty]
    private ArchitectureInfo? selectedArchitecture;

    [ObservableProperty]
    private string statusMessage = "Ready";

    [ObservableProperty]
    private bool isDetectingCompilers;

    [ObservableProperty]
    private bool isDetectingArchitecture;

    [ObservableProperty]
    private string sourceVersion = "stable";

    [ObservableProperty]
    private bool downloadNetwork = true;

    [ObservableProperty]
    private bool stripExecutable = true;

    [ObservableProperty]
    private bool enablePgo = true;

    [ObservableProperty]
    private int parallelJobs = Environment.ProcessorCount;

    [ObservableProperty]
    private string outputDirectory = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

    [ObservableProperty]
    private string detectionDetails = string.Empty;

    public IAsyncRelayCommand DetectCompilersCommand { get; }
    public IAsyncRelayCommand DetectArchitectureCommand { get; }

    private async Task DetectCompilersAsync()
    {
        try
        {
            IsDetectingCompilers = true;
            DetectionDetails = string.Empty;
            _logger.LogInformation("Starting compiler detection");
            StatusMessage = "Detecting compilers...";
            
            var compilers = await _compilerService.DetectCompilersAsync();
            
            AvailableCompilers = new ObservableCollection<CompilerInfo>(compilers);
            if (compilers.Count > 0)
            {
                SelectedCompiler = compilers[0];
                StatusMessage = $"Found {compilers.Count} compiler{(compilers.Count == 1 ? "" : "s")}";
                DetectionDetails = $"Found {compilers.Count} compiler(s). Check the logs for search details.";
            }
            else
            {
                StatusMessage = "No compilers found";
                DetectionDetails = BuildNoCompilersFoundMessage();
                _logger.LogWarning("No compilers found on system");
            }
            
            _logger.LogInformation("Found {Count} compilers", compilers.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting compilers");
            StatusMessage = $"Error detecting compilers: {ex.Message}";
            DetectionDetails = $"Error: {ex.Message}";
        }
        finally
        {
            IsDetectingCompilers = false;
        }
    }

    private static string BuildNoCompilersFoundMessage()
    {
        var msg = "No C++ compilers were found on your system.\n\n";
        msg += "Fastest fix: click \"Download & Install MSYS2 (GCC)\" above to grab everything automatically.\n\n";
        msg += "Searched locations:\n";
        msg += "  - MSYS2 (C:\\msys64, D:\\msys64, etc.)\n";
        msg += "  - Git for Windows MinGW\n";
        msg += "  - Visual Studio Clang/LLVM\n";
        msg += "  - Standalone MinGW installations\n";
        msg += "  - System PATH\n\n";
        msg += "To compile Stockfish, you need MSYS2 with MinGW-w64:\n\n";
        msg += "1. Download MSYS2 from: https://www.msys2.org/\n";
        msg += "2. Install to default location (C:\\msys64)\n";
        msg += "3. Open MSYS2 MSYS terminal and run:\n";
        msg += "   pacman -Syu\n";
        msg += "   pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-make\n\n";
        msg += "4. Then click 'Detect Compilers' again.";
        return msg;
    }

    private async Task DetectOptimalArchitectureAsync()
    {
        if (SelectedCompiler is null)
        {
            _logger.LogWarning("Cannot detect architecture - no compiler selected");
            StatusMessage = "Please select a compiler first";
            return;
        }
        
        try
        {
            IsDetectingArchitecture = true;
            _logger.LogInformation("Detecting optimal architecture for {Compiler}", SelectedCompiler.DisplayName);
            StatusMessage = "Detecting optimal CPU architecture...";
            
            var optimalArch = await _architectureDetector.DetectOptimalArchitectureAsync(SelectedCompiler);
            SelectedArchitecture = AvailableArchitectures.FirstOrDefault(a => a.Id == optimalArch.Id) ?? optimalArch;
            StatusMessage = $"Detected: {optimalArch.Name}";
            
            _logger.LogInformation("Detected architecture: {Architecture}", optimalArch.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting architecture");
            StatusMessage = $"Error detecting architecture: {ex.Message}";
        }
        finally
        {
            IsDetectingArchitecture = false;
        }
    }

    private async Task LoadAvailableArchitectures()
    {
        try
        {
            _logger.LogInformation("Loading available architectures");
            var list = await _architectureDetector.GetAvailableArchitecturesAsync();
            AvailableArchitectures = new ObservableCollection<ArchitectureInfo>(list);
            _logger.LogInformation("Loaded {Count} architectures", list.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading architectures");
        }
    }

    private void LoadUserSettings()
    {
        try
        {
            _isRestoringSettings = true;
            _userSettings = _userSettingsService.Load();

            DownloadNetwork = _userSettings.DownloadNetwork;
            StripExecutable = _userSettings.StripExecutable;
            EnablePgo = _userSettings.EnablePgo;
            ParallelJobs = _userSettings.ParallelJobs;

            if (!string.IsNullOrWhiteSpace(_userSettings.OutputDirectory))
                OutputDirectory = _userSettings.OutputDirectory;

            if (!string.IsNullOrWhiteSpace(_userSettings.SourceVersion))
                SourceVersion = _userSettings.SourceVersion;

            _logger.LogInformation("Loaded user settings from {Path}", _userSettingsService.SettingsFilePath);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not load user settings, using defaults");
        }
        finally
        {
            _isRestoringSettings = false;
        }
    }

    private void PersistUserSettings()
    {
        if (_isRestoringSettings)
            return;

        _userSettings.DownloadNetwork = DownloadNetwork;
        _userSettings.StripExecutable = StripExecutable;
        _userSettings.EnablePgo = EnablePgo;
        _userSettings.ParallelJobs = ParallelJobs;
        _userSettings.OutputDirectory = OutputDirectory;
        _userSettings.SourceVersion = SourceVersion;

        _userSettingsService.Save(_userSettings);
    }

    partial void OnDownloadNetworkChanged(bool value) => PersistUserSettings();
    partial void OnStripExecutableChanged(bool value) => PersistUserSettings();
    partial void OnEnablePgoChanged(bool value) => PersistUserSettings();
    partial void OnParallelJobsChanged(int value)
    {
        if (_isRestoringSettings || _isAdjustingParallelJobs)
            return;

        var maxJobs = Environment.ProcessorCount * 4;
        var clampedValue = Math.Clamp(value, 1, maxJobs);

        if (value != clampedValue)
        {
            _isAdjustingParallelJobs = true;
            ParallelJobs = clampedValue;
            _isAdjustingParallelJobs = false;
            StatusMessage = $"Warning: Parallel jobs adjusted to valid range (1-{maxJobs})";
        }

        PersistUserSettings();
    }

    partial void OnOutputDirectoryChanged(string value)
    {
        if (!ValidateOutputDirectory(value))
        {
            StatusMessage = "Warning: Invalid output directory path";
        }
        
        PersistUserSettings();
    }

    private bool ValidateOutputDirectory(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return false;

        try
        {
            // Check if path is rooted (absolute)
            if (!Path.IsPathRooted(path))
            {
                _logger.LogWarning("Output directory is not an absolute path: {Path}", path);
                return false;
            }

            // Get full path and check for invalid characters
            var fullPath = Path.GetFullPath(path);
            var invalidChars = Path.GetInvalidPathChars();

            if (path.Any(c => invalidChars.Contains(c)))
            {
                _logger.LogWarning("Output directory contains invalid characters: {Path}", path);
                return false;
            }

            // Try to create directory to verify write access
            if (!Directory.Exists(fullPath))
            {
                try
                {
                    Directory.CreateDirectory(fullPath);
                    _logger.LogInformation("Created output directory: {Path}", fullPath);
                }
                catch (UnauthorizedAccessException)
                {
                    _logger.LogWarning("No write access to output directory: {Path}", fullPath);
                    return false;
                }
            }

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error validating output directory: {Path}", path);
            return false;
        }
    }

    partial void OnSourceVersionChanged(string value) => PersistUserSettings();

    public string SystemInfo => $"{OSHelper.GetFriendlyOSName()} | {RuntimeInformation.ProcessArchitecture} | .NET {Environment.Version}";
}

==== END FILE: ViewModels\MainViewModel.cs ====

==== BEGIN FILE: ViewModels\BuildViewModel.cs (D:\GitHub\StockfishCompiler\ViewModels\BuildViewModel.cs) ====
using System.Collections.ObjectModel;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Threading;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;
using StockfishCompiler.Services;

namespace StockfishCompiler.ViewModels;

public partial class BuildViewModel : ObservableObject, IDisposable
{
    private readonly IBuildService _buildService;
    private readonly MainViewModel _mainViewModel;
    private readonly ILogger<BuildViewModel> _logger;
    private readonly List<IDisposable> _subscriptions = new();
    private readonly Queue<string> _logQueue = new();
    private readonly DispatcherTimer _updateTimer;
    private int _isDirty = 0;
    private readonly object _logLock = new();
    private bool _disposed;

    private const int MaxOutputLines = 1000;

    public BuildViewModel(IBuildService buildService, MainViewModel mainViewModel, ILogger<BuildViewModel> logger)
    {
        _buildService = buildService;
        _mainViewModel = mainViewModel;
        _logger = logger;

        _logger.LogInformation("BuildViewModel initializing");

        StartBuildCommand = new AsyncRelayCommand(StartBuildAsync, () => !IsBuilding);
        CancelBuildCommand = new RelayCommand(CancelBuild, () => IsBuilding);

        // Setup UI update timer to throttle output updates (4 times per second max)
        _updateTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromMilliseconds(250)
        };
        _updateTimer.Tick += (s, e) =>
        {
            if (Interlocked.Exchange(ref _isDirty, 0) == 1)
            {
                string output;
                lock (_logLock)
                {
                    output = string.Join(Environment.NewLine, _logQueue);
                }
                BuildOutput = output;
            }
        };
        _updateTimer.Start();

        // Marshal all observable subscriptions to UI thread
        var uiScheduler = new SynchronizationContextScheduler(SynchronizationContext.Current!);
        
        _subscriptions.Add(_buildService.Output
            .ObserveOn(uiScheduler)
            .Subscribe(
                onNext: line => AppendOutput(line),
                onError: ex =>
                {
                    _logger.LogError(ex, "Error in build output stream");
                    AppendOutput($"[Error: {ex.Message}]");
                }));

        _subscriptions.Add(_buildService.Progress
            .ObserveOn(uiScheduler)
            .Subscribe(
                onNext: p => BuildProgress = p,
                onError: ex =>
                {
                    _logger.LogError(ex, "Error in build progress stream");
                    AppendOutput($"[Error updating progress: {ex.Message}]");
                }));
        
        _subscriptions.Add(_buildService.IsBuilding
            .ObserveOn(uiScheduler)
            .Subscribe(
                onNext: b =>
                {
                    IsBuilding = b;
                    StartBuildCommand.NotifyCanExecuteChanged();
                    CancelBuildCommand.NotifyCanExecuteChanged();
                },
                onError: ex =>
                {
                    _logger.LogError(ex, "Error in build state stream");
                    AppendOutput($"[Error updating build state: {ex.Message}]");
                }));

        _logger.LogInformation("BuildViewModel initialized");
    }

    [ObservableProperty]
    private string buildOutput = string.Empty;

    [ObservableProperty]
    private double buildProgress = 0;

    [ObservableProperty]
    private bool isBuilding = false;

    public IAsyncRelayCommand StartBuildCommand { get; }
    public IRelayCommand CancelBuildCommand { get; }

    private void AppendOutput(string line)
    {
        lock (_logLock)
        {
            _logQueue.Enqueue(line);
            while (_logQueue.Count > MaxOutputLines)
            {
                _logQueue.Dequeue();
            }
        }
        Interlocked.Exchange(ref _isDirty, 1);
    }

    private async Task StartBuildAsync()
    {
        // Clear output queue and display
        lock (_logLock)
        {
            _logQueue.Clear();
        }
        BuildOutput = string.Empty;
        BuildProgress = 0;

        _logger.LogInformation("Starting build process");

        var config = new BuildConfiguration
        {
            SelectedCompiler = _mainViewModel.SelectedCompiler,
            SelectedArchitecture = _mainViewModel.SelectedArchitecture,
            SourceVersion = _mainViewModel.SourceVersion,
            DownloadNetwork = _mainViewModel.DownloadNetwork,
            StripExecutable = _mainViewModel.StripExecutable,
            EnablePgo = _mainViewModel.EnablePgo,
            ParallelJobs = _mainViewModel.ParallelJobs,
            OutputDirectory = _mainViewModel.OutputDirectory
        };

        if (config.SelectedCompiler == null)
        {
            _logger.LogWarning("Build aborted - no compiler selected");
            BuildOutput = "Error: No compiler selected. Please go to Compiler Setup tab and detect compilers.\n";
            return;
        }

        if (config.SelectedArchitecture == null)
        {
            _logger.LogWarning("Build aborted - no architecture selected");
            BuildOutput = "Error: No architecture selected. Please go to Compiler Setup tab and detect architecture.\n";
            return;
        }

        _logger.LogInformation("Build configuration: Compiler={Compiler}, Arch={Arch}, Version={Version}, Jobs={Jobs}",
            config.SelectedCompiler.DisplayName,
            config.SelectedArchitecture.Id,
            config.SourceVersion,
            config.ParallelJobs);

        var result = await _buildService.BuildAsync(config);

        if (result.Success)
        {
            _logger.LogInformation("Build completed successfully");
            AppendOutput("\n==============================================");
            AppendOutput("Compilation successful!");
            AppendOutput("==============================================");
        }
        else
        {
            _logger.LogError("Build failed with exit code {ExitCode}", result.ExitCode);
            AppendOutput("\n==============================================");
            AppendOutput("Compilation failed!");
            AppendOutput($"Exit code: {result.ExitCode}");
            AppendOutput("==============================================");
        }
    }

    private void CancelBuild()
    {
        _logger.LogInformation("Build cancelled by user");
        _buildService.CancelBuild();
        AppendOutput("\n[Build cancelled by user]");
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _updateTimer?.Stop();
        
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
        _subscriptions.Clear();
        GC.SuppressFinalize(this);
    }
}

==== END FILE: ViewModels\BuildViewModel.cs ====

==== BEGIN FILE: Models\ArchitectureInfo.cs (D:\GitHub\StockfishCompiler\Models\ArchitectureInfo.cs) ====
namespace StockfishCompiler.Models;

public class ArchitectureInfo
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty; // x86, ARM, PPC, etc.
    public bool IsRecommended { get; set; }
    public List<string> Features { get; set; } = [];

    public override string ToString() => Name;
}

==== END FILE: Models\ArchitectureInfo.cs ====

==== BEGIN FILE: Models\BuildConfiguration.cs (D:\GitHub\StockfishCompiler\Models\BuildConfiguration.cs) ====
namespace StockfishCompiler.Models;

public class BuildConfiguration
{
    public CompilerInfo? SelectedCompiler { get; set; }
    public ArchitectureInfo? SelectedArchitecture { get; set; }
    public string SourceVersion { get; set; } = "stable"; // stable, development
    public bool DownloadNetwork { get; set; } = true;
    public bool StripExecutable { get; set; } = true;
    public bool EnablePgo { get; set; } = true;
    public int ParallelJobs { get; set; } = Environment.ProcessorCount;
    public string OutputDirectory { get; set; } = string.Empty;
}

==== END FILE: Models\BuildConfiguration.cs ====

==== BEGIN FILE: Models\CompilationResult.cs (D:\GitHub\StockfishCompiler\Models\CompilationResult.cs) ====
namespace StockfishCompiler.Models;

public class CompilationResult
{
    public bool Success { get; set; }
    public string Output { get; set; } = string.Empty;
    public int ExitCode { get; set; }
}

==== END FILE: Models\CompilationResult.cs ====

==== BEGIN FILE: Models\CompilerInfo.cs (D:\GitHub\StockfishCompiler\Models\CompilerInfo.cs) ====
namespace StockfishCompiler.Models;

public class CompilerInfo
{
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty; // gcc, clang, msvc, mingw
    public string Version { get; set; } = string.Empty;
    public string Path { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public bool IsAvailable { get; set; }

    public override string ToString() => DisplayName;
}

==== END FILE: Models\CompilerInfo.cs ====

==== BEGIN FILE: Models\UserSettings.cs (D:\GitHub\StockfishCompiler\Models\UserSettings.cs) ====
using System;

namespace StockfishCompiler.Models;

public class UserSettings
{
    public bool DownloadNetwork { get; set; } = true;
    public bool StripExecutable { get; set; } = true;
    public bool EnablePgo { get; set; } = true;
    public int ParallelJobs { get; set; } = Environment.ProcessorCount;
    public string OutputDirectory { get; set; } = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
    public string SourceVersion { get; set; } = "stable";
}

==== END FILE: Models\UserSettings.cs ====

==== BEGIN FILE: Services\IArchitectureDetector.cs (D:\GitHub\StockfishCompiler\Services\IArchitectureDetector.cs) ====
using StockfishCompiler.Models;
using System.Threading;

namespace StockfishCompiler.Services;

public interface IArchitectureDetector
{
    Task<ArchitectureInfo> DetectOptimalArchitectureAsync(CompilerInfo compiler, CancellationToken cancellationToken = default);
    Task<List<ArchitectureInfo>> GetAvailableArchitecturesAsync();
    Task<List<string>> DetectCPUFeaturesAsync(CompilerInfo compiler, CancellationToken cancellationToken = default);
}

==== END FILE: Services\IArchitectureDetector.cs ====

==== BEGIN FILE: Services\ArchitectureDetector.cs (D:\GitHub\StockfishCompiler\Services\ArchitectureDetector.cs) ====
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Threading;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class ArchitectureDetector : IArchitectureDetector
{
    private static readonly string[] X64BaseFeatures = ["sse4.1", "popcnt", "avx2", "bmi2"];
    private static readonly string[] Arm64BaseFeatures = ["neon", "popcnt"];
    private readonly ILogger<ArchitectureDetector> _logger;

    public ArchitectureDetector(ILogger<ArchitectureDetector> logger)
    {
        _logger = logger;
    }

    public async Task<ArchitectureInfo> DetectOptimalArchitectureAsync(CompilerInfo compiler, CancellationToken cancellationToken = default)
    {
        try
        {
            var (features, detectedCpu) = await DetectCPUFeaturesDetailedAsync(compiler, cancellationToken);
            _logger.LogDebug("Detected {Count} CPU features: {Features}", features.Count, string.Join(", ", features));
            _logger.LogDebug("Detected CPU name: {CpuName}", detectedCpu);
            
            var archId = DetermineOptimalArchitecture(features, detectedCpu);
            _logger.LogInformation("Determined optimal architecture: {Architecture}", archId);
            
            var all = await GetAvailableArchitecturesAsync();
            var matched = all.FirstOrDefault(a => a.Id.Equals(archId, StringComparison.OrdinalIgnoreCase));
            return matched ?? new ArchitectureInfo 
            { 
                Id = archId, 
                Name = archId, 
                Description = archId, 
                Category = RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ? "ARM" : "x86" 
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Architecture detection failed for {Compiler}, using fallback", compiler.DisplayName);
            
            // Fallback to safe generic architecture based on platform
            var fallbackId = RuntimeInformation.ProcessArchitecture == Architecture.Arm64 
                ? "armv8" 
                : "x86-64";
            
            var all = await GetAvailableArchitecturesAsync();
            var fallback = all.FirstOrDefault(a => a.Id == fallbackId);
            
            return fallback ?? new ArchitectureInfo
            {
                Id = fallbackId,
                Name = fallbackId,
                Description = $"{fallbackId} (fallback - detection failed)",
                Category = RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ? "ARM" : "x86",
                IsRecommended = false
            };
        }
    }

    public async Task<List<string>> DetectCPUFeaturesAsync(CompilerInfo compiler, CancellationToken cancellationToken = default)
    {
        var (features, _) = await DetectCPUFeaturesDetailedAsync(compiler, cancellationToken);
        return features;
    }

    private async Task<(List<string> Features, string CpuName)> DetectCPUFeaturesDetailedAsync(CompilerInfo compiler, CancellationToken cancellationToken)
    {
        try
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
            {
                _logger.LogInformation("ARM64 architecture detected, using base features");
                return (Arm64BaseFeatures.ToList(), "arm64");
            }

            if (compiler.Type is "gcc" or "mingw")
            {
                _logger.LogDebug("Using GCC feature detection for {Compiler}", compiler.DisplayName);
                return await DetectGccFeaturesAsync(compiler, cancellationToken);
            }
            if (compiler.Type == "clang")
            {
                _logger.LogDebug("Using Clang feature detection for {Compiler}", compiler.DisplayName);
                return await DetectClangFeaturesAsync(compiler, cancellationToken);
            }
            
            _logger.LogWarning("Unknown compiler type: {Type}, using fallback", compiler.Type);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Feature detection failed, using fallback features");
        }

        return GetFallbackFeatures();
    }

    private async Task<(List<string> Features, string CpuName)> DetectGccFeaturesAsync(CompilerInfo compiler, CancellationToken cancellationToken)
    {
        var exe = Path.Combine(compiler.Path, compiler.Name);
        _logger.LogDebug("Running GCC detection: {Exe} -Q -march=native --help=target", exe);
        
        var psi = new ProcessStartInfo
        {
            FileName = exe,
            Arguments = "-Q -march=native --help=target",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        // Force C (English) locale to ensure output parsing works on non-English systems
        psi.EnvironmentVariables["LC_ALL"] = "C";
        psi.EnvironmentVariables["LANG"] = "C";

        SetupEnvironmentForMSYS2(psi, compiler.Path);

        using var process = Process.Start(psi);
        if (process == null)
        {
            _logger.LogWarning("Failed to start GCC process for feature detection");
            return (X64BaseFeatures.ToList(), "unknown");
        }

        var stdoutTask = process.StandardOutput.ReadToEndAsync();
        var stderrTask = process.StandardError.ReadToEndAsync();
        
        await process.WaitForExitAsync(cancellationToken);
        
        var stdout = await stdoutTask;
        var stderr = await stderrTask;

        if (process.ExitCode != 0)
        {
            _logger.LogWarning("GCC detection exited with code {ExitCode}", process.ExitCode);
            if (!string.IsNullOrWhiteSpace(stderr))
            {
                _logger.LogDebug("GCC stderr: {StdErr}", stderr.Substring(0, Math.Min(500, stderr.Length)));
            }
        }

        // If there were errors and no output, throw to trigger fallback
        if (process.ExitCode != 0 && string.IsNullOrWhiteSpace(stdout))
        {
            throw new InvalidOperationException($"GCC detection failed with exit code {process.ExitCode}");
        }

        var features = new List<string>();
        string cpuName = "";
        foreach (var line in stdout.Split('\n'))
        {
            var trimmed = line.Trim();
            if (trimmed.StartsWith("-march", StringComparison.Ordinal))
            {
                var parts = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                cpuName = parts.LastOrDefault() ?? string.Empty;
            }
            if (trimmed.Contains("[enabled]"))
            {
                if (!trimmed.Contains("-m", StringComparison.Ordinal))
                    continue;

                var flag = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries)
                                  .FirstOrDefault(s => s.StartsWith("-m", StringComparison.Ordinal));
                if (!string.IsNullOrWhiteSpace(flag))
                {
                    var name = flag.Length > 2 ? flag[2..] : flag;
                    if (!string.IsNullOrWhiteSpace(name))
                        features.Add(name);
                }
            }
        }

        _logger.LogDebug("GCC detection found {Count} features", features.Count);
        var distinct = features.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        if (distinct.Count == 0)
        {
            _logger.LogWarning("No target features detected from GCC output; falling back to base feature detection");
            return GetFallbackFeatures();
        }
        return (distinct, cpuName);
    }

    private async Task<(List<string> Features, string CpuName)> DetectClangFeaturesAsync(CompilerInfo compiler, CancellationToken cancellationToken)
    {
        var exe = Path.Combine(compiler.Path, compiler.Name);
        _logger.LogDebug("Running Clang detection: {Exe} -E - -march=native -###", exe);
        
        var psi = new ProcessStartInfo
        {
            FileName = exe,
            Arguments = "-E - -march=native -###",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        // Force C (English) locale to ensure output parsing works on non-English systems
        psi.EnvironmentVariables["LC_ALL"] = "C";
        psi.EnvironmentVariables["LANG"] = "C";

        SetupEnvironmentForMSYS2(psi, compiler.Path);

        using var process = Process.Start(psi);
        if (process == null)
        {
            _logger.LogWarning("Failed to start Clang process for feature detection");
            return (X64BaseFeatures.ToList(), "unknown");
        }

        var stdoutTask = process.StandardOutput.ReadToEndAsync();
        var stderrTask = process.StandardError.ReadToEndAsync();
        
        await process.WaitForExitAsync(cancellationToken);
        
        var stdout = await stdoutTask;
        var stderr = await stderrTask;

        var features = new List<string>();
        string cpuName = "";
        foreach (var line in stderr.Split('\n'))
        {
            var trimmed = line.Trim();
            if (trimmed.Contains("-target-cpu"))
            {
                var parts = trimmed.Split('"');
                cpuName = parts.LastOrDefault() ?? string.Empty;
            }
            if (trimmed.Contains("-target-feature"))
            {
                var parts = trimmed.Split('"');
                var feat = parts.LastOrDefault();
                if (!string.IsNullOrEmpty(feat) && feat.StartsWith('+'))
                {
                    var name = feat.Length > 1 ? feat[1..] : feat;
                    if (!string.IsNullOrWhiteSpace(name))
                        features.Add(name);
                }
            }
        }

        _logger.LogDebug("Clang detection found {Count} features", features.Count);
        var distinct = features.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        if (distinct.Count == 0)
        {
            _logger.LogWarning("No target features detected from Clang output; falling back to base feature detection");
            return GetFallbackFeatures();
        }
        return (distinct, cpuName);
    }

    private void SetupEnvironmentForMSYS2(ProcessStartInfo psi, string compilerPath)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return;

        var compilerDir = new DirectoryInfo(compilerPath);
        var msys2Root = compilerDir.Parent?.Parent;

        if (msys2Root != null && msys2Root.Exists)
        {
            var pathsToAdd = new List<string>();

            pathsToAdd.Add(compilerPath);

            var usrBin = Path.Combine(msys2Root.FullName, "usr", "bin");
            var mingw64Bin = Path.Combine(msys2Root.FullName, "mingw64", "bin");
            var mingw32Bin = Path.Combine(msys2Root.FullName, "mingw32", "bin");

            if (Directory.Exists(usrBin))
                pathsToAdd.Add(usrBin);
            if (Directory.Exists(mingw64Bin))
                pathsToAdd.Add(mingw64Bin);
            if (Directory.Exists(mingw32Bin))
                pathsToAdd.Add(mingw32Bin);

            var currentPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
            var newPath = string.Join(";", pathsToAdd) + ";" + currentPath;
            psi.EnvironmentVariables["PATH"] = newPath;
            
            _logger.LogDebug("Set up MSYS2 environment with paths: {Paths}", string.Join("; ", pathsToAdd));
        }
        else
        {
            _logger.LogDebug("MSYS2 root not found for compiler path: {Path}", compilerPath);
        }
    }

    private static string DetermineOptimalArchitecture(List<string> features, string cpuName)
    {
        bool Has(params string[] req) => req.All(f => features.Contains(f));
        string cpu = cpuName.ToLowerInvariant();

        if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
            return "armv8";

        if (Has("avx512vnni", "avx512dq", "avx512f", "avx512bw", "avx512vl"))
            return "x86-64-vnni256";
        if (Has("avx512f", "avx512bw"))
            return "x86-64-avx512";
        if (Has("bmi2") && cpu is not ("znver1" or "znver2"))
            return "x86-64-bmi2";
        if (Has("avx2"))
            return "x86-64-avx2";
        if (Has("sse4.1", "popcnt"))
            return "x86-64-sse41-popcnt";
        if (Has("ssse3"))
            return "x86-64-ssse3";
        if (Has("sse3", "popcnt"))
            return "x86-64-sse3-popcnt";
        return "x86-64";
    }

    private (List<string> Features, string CpuName) GetFallbackFeatures()
    {
        var features = RuntimeInformation.ProcessArchitecture switch
        {
            Architecture.X64 => X64BaseFeatures.ToList(),
            Architecture.Arm64 => Arm64BaseFeatures.ToList(),
            _ => new List<string>()
        };
        return (features, RuntimeInformation.ProcessArchitecture.ToString().ToLowerInvariant());
    }

    public Task<List<ArchitectureInfo>> GetAvailableArchitecturesAsync()
    {
        List<ArchitectureInfo> list =
        [
            new() { Id = "x86-64", Name = "x86-64", Description = "Generic 64-bit", Category = "x86" },
            new() { Id = "x86-64-vnni512", Name = "x86-64 VNNI 512", Description = "Intel Sapphire Rapids+, AMD Zen 4+", Category = "x86" },
            new() { Id = "x86-64-vnni256", Name = "x86-64 VNNI 256", Description = "Intel Cascade Lake+", Category = "x86" },
            new() { Id = "x86-64-avx512", Name = "x86-64 AVX-512", Description = "Intel Skylake-X+", Category = "x86" },
            new() { Id = "x86-64-bmi2", Name = "x86-64 BMI2", Description = "Intel Haswell+ (NOT AMD Zen 1/2)", Category = "x86" },
            new() { Id = "x86-64-avx2", Name = "x86-64 AVX2", Description = "Intel Haswell+, AMD Zen+", Category = "x86" },
            new() { Id = "x86-64-sse41-popcnt", Name = "x86-64 SSE4.1+POPCNT", Description = "Intel Nehalem+", Category = "x86" },
            new() { Id = "x86-64-ssse3", Name = "x86-64 SSSE3", Description = "Intel Core 2+, some early x86-64", Category = "x86" },
            new() { Id = "x86-64-sse3-popcnt", Name = "x86-64 SSE3+POPCNT", Description = "Older x86-64 with SSE3 + POPCNT", Category = "x86" },
            new() { Id = "armv8", Name = "ARMv8", Description = "ARMv8 64-bit with popcnt and neon", Category = "ARM" },
            new() { Id = "apple-silicon", Name = "Apple Silicon", Description = "Apple M1/M2/M3", Category = "ARM" }
        ];
        return Task.FromResult(list);
    }
}

==== END FILE: Services\ArchitectureDetector.cs ====

==== BEGIN FILE: Services\IBuildService.cs (D:\GitHub\StockfishCompiler\Services\IBuildService.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IBuildService
{
    IObservable<string> Output { get; }
    IObservable<double> Progress { get; }
    IObservable<bool> IsBuilding { get; }

    Task<CompilationResult> BuildAsync(BuildConfiguration configuration);
    void CancelBuild();
}

==== END FILE: Services\IBuildService.cs ====

==== BEGIN FILE: Services\BuildService.cs (D:\GitHub\StockfishCompiler\Services\BuildService.cs) ====
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using StockfishCompiler.Constants;
using StockfishCompiler.Helpers;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class BuildService(IStockfishDownloader downloader) : IBuildService, IDisposable
{
    public IObservable<string> Output => _outputSubject.AsObservable();
    public IObservable<double> Progress => _progressSubject.AsObservable();
    public IObservable<bool> IsBuilding => _isBuildingSubject.AsObservable();

    private readonly Subject<string> _outputSubject = new();
    private readonly Subject<double> _progressSubject = new();
    private readonly Subject<bool> _isBuildingSubject = new();
    private CancellationTokenSource? _cts;
    private bool _disposed;

    private const int MaxOutputCharacters = 500_000; // safety cap

    /// <summary>
    /// Executes a file operation and optionally fails the build when it cannot complete.
    /// </summary>
    private void ExecuteFileOperation(Action operation, string operationName, bool critical = true)
    {
        try
        {
            operation();
        }
        catch (Exception ex)
        {
            var severity = critical ? "Error" : "Warning";
            _outputSubject.OnNext($"{severity}: {operationName} failed: {ex.Message}");
            if (critical)
            {
                throw;
            }
        }
    }

    public async Task<CompilationResult> BuildAsync(BuildConfiguration configuration)
    {
        _cts = new CancellationTokenSource();
        _isBuildingSubject.OnNext(true);
        _progressSubject.OnNext(0);
        SourceDownloadResult? downloadResult = null;

        try
        {
            var progress = new Progress<string>(msg => _outputSubject.OnNext(msg));
            var token = _cts.Token;

            // Download source
            _outputSubject.OnNext("Downloading Stockfish source...");
            downloadResult = await downloader.DownloadSourceAsync(configuration.SourceVersion, progress, token);
            var sourceDir = downloadResult.SourceDirectory;
            _progressSubject.OnNext(25);

            if (configuration.DownloadNetwork)
            {
                var networkReady = await downloader.DownloadNeuralNetworkAsync(sourceDir, configuration, progress, token);
                if (!networkReady)
                    _outputSubject.OnNext("Pre-download failed - make will attempt to fetch the network.");
                _progressSubject.OnNext(networkReady ? 40 : 30);
            }

            ExecuteFileOperation(() =>
            {
                if (CreatePlaceholderNetwork(sourceDir))
                    _outputSubject.OnNext("Created placeholder network file for LTO linking.");
            }, "Placeholder network creation", critical: false);

            // Verify neural network files are in place and decide build strategy
            var canUsePGO = VerifyNetworkFilesForPGO(sourceDir);
            var usePgo = configuration.EnablePgo && canUsePGO;

            if (usePgo)
            {
                ExecuteFileOperation(() =>
                {
                    if (BypassNetScriptIfNetworksPresent(downloadResult.RootDirectory))
                        _outputSubject.OnNext("Bypassing net.sh because networks are already validated.");
                }, "net.sh bypass", critical: false);
            }
            else
            {
                if (!configuration.EnablePgo)
                {
                    _outputSubject.OnNext("PGO disabled in build options. Using standard optimized build.");
                }
                else if (!canUsePGO)
                {
                    _outputSubject.OnNext("Warning: Valid neural network not found. Using standard build instead of PGO.");
                }
            }

            var buildTarget = usePgo ? BuildTargets.ProfileBuild : BuildTargets.Build;

            // Compile
            _outputSubject.OnNext($"Compiling Stockfish using '{buildTarget}' target...");
            var result = await CompileStockfishAsync(sourceDir, configuration, token, buildTarget);
            _progressSubject.OnNext(90);

            // Strip and copy
            if (result.Success && configuration.StripExecutable)
            {
                _outputSubject.OnNext("Stripping executable...");
                await StripExecutableAsync(sourceDir, configuration, token);
            }

            if (result.Success)
            {
                _outputSubject.OnNext("Copying executable...");
                CopyExecutable(sourceDir, configuration);
            }

            _progressSubject.OnNext(100);
            return result;
        }
        catch (OperationCanceledException)
        {
            return new CompilationResult { Success = false, Output = "Canceled", ExitCode = -1 };
        }
        catch (Exception ex)
        {
            _outputSubject.OnNext($"Build failed: {ex.Message}");
            return new CompilationResult { Success = false, Output = ex.ToString(), ExitCode = -1 };
        }
        finally
        {
            CleanupTempDirectoryWithRetry(downloadResult?.TempDirectory, "temporary Stockfish source directory");
            _isBuildingSubject.OnNext(false);
        }
    }

    public void CancelBuild() => _cts?.Cancel();

    private async Task<CompilationResult> CompileStockfishAsync(string sourcePath, BuildConfiguration config, CancellationToken token, string buildTarget = BuildTargets.ProfileBuild)
    {
        var safeArch = SanitizeArchitecture(config.SelectedArchitecture?.Id);
        var safeJobs = SanitizeParallelJobs(config.ParallelJobs);
        var compType = GetCompType(config);
        var makeCmd = MSYS2Helper.FindMakeExecutable(config.SelectedCompiler?.Path);
        var env = MSYS2Helper.SetupEnvironment(config);

        // Ensure PGO profile data lands in a short, writable path to avoid GCOV path explosions on Windows
        // Use unique directory per build to avoid conflicts between concurrent builds
        string? profileDir = null;
        try
        {
            profileDir = Path.Combine(Path.GetTempPath(), $"sf_prof_{Guid.NewGuid():N}");
            Directory.CreateDirectory(profileDir);
            env["PROFDIR"] = profileDir;
            env["GCOV_PREFIX"] = profileDir;
            env["GCOV_PREFIX_STRIP"] = "10";
            env["LLVM_PROFILE_FILE"] = Path.Combine(profileDir, "default_%m.profraw");
        }
        catch
        {
            // If we cannot manage the profile directory, let GCC fall back; build will still succeed without PGO gains
        }

        _outputSubject.OnNext($"Using make: {makeCmd}");
        _outputSubject.OnNext($"Config: Jobs={safeJobs}, Arch={safeArch}, Comp={compType}, Target={buildTarget}");

        using var process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = makeCmd,
                WorkingDirectory = sourcePath,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            }
        };

        process.StartInfo.ArgumentList.Add($"-j{safeJobs}");
        process.StartInfo.ArgumentList.Add(buildTarget);
        process.StartInfo.ArgumentList.Add($"ARCH={safeArch}");
        process.StartInfo.ArgumentList.Add($"COMP={compType}");

        // Suppress noisy missing-profile warnings during profile-build; GCC will still fall back safely when data is absent.
        if (string.Equals(buildTarget, BuildTargets.ProfileBuild, StringComparison.OrdinalIgnoreCase))
        {
            process.StartInfo.ArgumentList.Add("EXTRAPROFILEFLAGS=-Wno-missing-profile");
        }

        foreach (var kvp in env)
            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;

        process.Start();

        using var registration = token.Register(() =>
        {
            try
            {
                if (!process.HasExited)
                {
                    try
                    {
                        process.Kill(entireProcessTree: true);
                    }
                    catch (PlatformNotSupportedException)
                    {
                        process.Kill();
                    }
                    catch (InvalidOperationException)
                    {
                        // Process already exited
                    }
                }
            }
            catch
            {
                // Ignore kill failures; process may have already exited
            }
        });

        var outputBuilder = new StringBuilder();
        Task ReadAsync(StreamReader reader) => Task.Run(async () =>
        {
            while (!reader.EndOfStream)
            {
                token.ThrowIfCancellationRequested();
                var line = await reader.ReadLineAsync();
                if (line == null) break;
                AppendOutput(outputBuilder, line);
            }
        }, token);

        var readStdOut = ReadAsync(process.StandardOutput);
        var readStdErr = ReadAsync(process.StandardError);
        var waitExit = process.WaitForExitAsync(token);

        try
        {
            await Task.WhenAll(readStdOut, readStdErr, waitExit);

            return new CompilationResult
            {
                Success = process.ExitCode == 0,
                Output = outputBuilder.ToString(),
                ExitCode = process.ExitCode
            };
        }
        finally
        {
            // Clean up profile data even on failure/cancel to avoid cluttering %TEMP%
            CleanupTempDirectoryWithRetry(profileDir, "profile data directory");
        }
    }

    private void AppendOutput(StringBuilder builder, string line)
    {
        builder.AppendLine(line);
        if (builder.Length > MaxOutputCharacters)
            builder.Remove(0, builder.Length - MaxOutputCharacters); // trim oldest
        _outputSubject.OnNext(line);
    }

    private async Task StripExecutableAsync(string sourcePath, BuildConfiguration config, CancellationToken token)
    {
        var makeCmd = MSYS2Helper.FindMakeExecutable(config.SelectedCompiler?.Path);
        var env = MSYS2Helper.SetupEnvironment(config);

        using var process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = makeCmd,
                WorkingDirectory = sourcePath,
                RedirectStandardOutput = false,
                RedirectStandardError = false,
                UseShellExecute = false,
                CreateNoWindow = true
            }
        };
        process.StartInfo.ArgumentList.Add("strip");
        process.StartInfo.ArgumentList.Add($"COMP={GetCompType(config)}");
        foreach (var kvp in env)
            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;
        process.Start();
        await process.WaitForExitAsync(token);
    }

    private void CopyExecutable(string sourcePath, BuildConfiguration config)
    {
        var exeName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "stockfish.exe" : "stockfish";
        var sourceExe = Path.Combine(sourcePath, exeName);
        if (!File.Exists(sourceExe))
        {
            _outputSubject.OnNext($"Warning: Could not find {sourceExe}");
            return;
        }
        var safeArch = SanitizeArchitecture(config.SelectedArchitecture?.Id);
        var outputNameRaw = $"stockfish_{safeArch}_{config.SourceVersion}{(RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : "")}";
        var outputPath = ValidateOutputPath(config.OutputDirectory, outputNameRaw);
        try
        {
            File.Copy(sourceExe, outputPath, true);
            _outputSubject.OnNext($"Executable saved to: {outputPath}");
        }
        catch (Exception ex)
        {
            _outputSubject.OnNext($"Failed to copy executable: {ex.Message}");
            throw;
        }
    }

    private static string GetCompType(BuildConfiguration config)
    {
        if (config.SelectedCompiler == null) return CompilerType.GCC;
        return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && config.SelectedCompiler.Type == CompilerType.GCC 
            ? CompilerType.MinGW 
            : config.SelectedCompiler.Type;
    }

    // Note: The following Makefile/script manipulation helpers are kept for reference.
    // They are currently not invoked because the build flow relies on verified networks
    // plus a net.sh bypass when networks are present, which avoids mutating upstream files.
    #region LegacyBuildTweaks
    private static bool DisableNetDependency(string sourceDirectory)
    {
        var makefilePath = Path.Combine(sourceDirectory, "Makefile");
        if (!File.Exists(makefilePath)) return false;
        
        var lines = File.ReadAllLines(makefilePath).ToList();
        bool changed = false;
        
        var targetsToPatch = new[] 
        { 
            BuildTargets.ProfileBuild, 
            BuildTargets.Build, 
            BuildTargets.ConfigSanity, 
            BuildTargets.Analyze 
        };

        for (int i = 0; i < lines.Count; i++)
        {
            var trimmedLine = lines[i].TrimStart();
            
            // Check if this line defines one of our targets
            foreach (var target in targetsToPatch)
            {
                if (trimmedLine.StartsWith($"{target}:", StringComparison.Ordinal))
                {
                    // Process this line and any continuations
                    var lineIndicesToProcess = new List<int> { i };
                    
                    // Collect all lines that are part of this rule (handle line continuations)
                    int j = i;
                    while (j < lines.Count && lines[j].TrimEnd().EndsWith("\\", StringComparison.Ordinal))
                    {
                        j++;
                        if (j < lines.Count)
                        {
                            lineIndicesToProcess.Add(j);
                        }
                    }
                    
                    // Remove 'net' from all collected lines
                    foreach (var lineIdx in lineIndicesToProcess)
                    {
                        var line = lines[lineIdx];
                        
                        // Remove 'net' as a standalone dependency
                        // Match patterns: " net ", " net\", "net ", " net", or ":net"
                        if (line.Contains(" net ") || 
                            line.Contains(" net\\") ||
                            line.Contains($":{target.Split(':')[0]} net") ||
                            line.TrimEnd().EndsWith(" net"))
                        {
                            // Replace multiple patterns
                            var newLine = line
                                .Replace(" net ", " ")
                                .Replace(" net\\", "\\")
                                .Replace(" net\t", " ")
                                .Replace("\tnet ", "\t")
                                .Replace("\tnet\t", "\t");
                            
                            // Handle 'net' at the end of line (before potential backslash)
                            if (newLine.TrimEnd('\\').TrimEnd().EndsWith(" net"))
                            {
                                var endsWithBackslash = newLine.TrimEnd().EndsWith("\\");
                                newLine = newLine.TrimEnd('\\').TrimEnd();
                                newLine = newLine.Substring(0, newLine.Length - 4); // Remove " net"
                                if (endsWithBackslash)
                                {
                                    newLine += " \\";
                                }
                            }
                            
                            if (newLine != line)
                            {
                                lines[lineIdx] = newLine;
                                changed = true;
                            }
                        }
                    }
                    
                    break; // Move to next line after processing this target
                }
            }
        }
        
        if (changed)
        {
            File.WriteAllLines(makefilePath, lines);
            return true;
        }
        
        return false;
    }

    private bool NeutralizeNetScript(string rootDirectory)
    {
        if (string.IsNullOrWhiteSpace(rootDirectory)) return false;
        var scriptPath = Path.Combine(rootDirectory, "scripts", "net.sh");
        if (!File.Exists(scriptPath)) return false;
        var scriptContent = """
#!/bin/sh
echo "Skipping Stockfish net target - neural networks pre-downloaded."
exit 0
""";
        File.WriteAllText(scriptPath, scriptContent.Replace("\r\n", "\n"));
        return true;
    }

    private static bool PatchMakefileSaveTemps(string sourceDirectory)
    {
        var makefilePath = Path.Combine(sourceDirectory, "Makefile");
        if (!File.Exists(makefilePath)) return false;
        
        var content = File.ReadAllText(makefilePath);
        var originalContent = content;
        
        // Remove -save-temps flag (as a standalone word, not adjacent whitespace)
        // Uses lookbehind (?<=\s) to ensure preceded by whitespace
        // Uses lookahead (?=\s|$) to ensure followed by whitespace or end of line
        // This preserves Makefile syntax and line continuations
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"(?<=\s)-save-temps(?=\s|$)",
            "",
            System.Text.RegularExpressions.RegexOptions.Multiline
        );
        
        if (content != originalContent)
        {
            File.WriteAllText(makefilePath, content);
            return true;
        }
        
        return false;
    }
    #endregion

    private static bool CreatePlaceholderNetwork(string sourceDirectory)
    {
        // If valid networks are already present, nothing to do.
        if (Directory.GetFiles(sourceDirectory, "*.nnue").Any())
            return false;

        var targetNames = DetectNetworkNames(sourceDirectory);
        if (targetNames.Count == 0)
            targetNames.Add("nn-1c0000000000.nnue"); // fallback to classic default

        var dummyData = new byte[1024];
        dummyData[0] = 0x4E; // N
        dummyData[1] = 0x4E; // N
        dummyData[2] = 0x55; // U
        dummyData[3] = 0x45; // E

        var created = false;
        foreach (var name in targetNames)
        {
            var path = Path.Combine(sourceDirectory, name);
            if (!File.Exists(path))
            {
                File.WriteAllBytes(path, dummyData);
                created = true;
            }
        }

        return created;
    }

    private static List<string> DetectNetworkNames(string sourceDirectory)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var candidates = new[]
        {
            Path.Combine(sourceDirectory, "evaluate.h"),
            Path.Combine(sourceDirectory, "nnue", "evaluate.h")
        };

        var regex = new Regex("#define\\s+EvalFileDefaultName\\w*\\s+\"(nn-[a-z0-9]{12}\\.nnue)\"", RegexOptions.IgnoreCase);

        foreach (var candidate in candidates)
        {
            if (!File.Exists(candidate)) continue;
            var contents = File.ReadAllText(candidate);
            foreach (Match m in regex.Matches(contents))
            {
                if (m.Success)
                    names.Add(m.Groups[1].Value);
            }
        }

        return names.ToList();
    }

    private bool VerifyNetworkFilesForPGO(string sourceDirectory)
    {
        var nnueFiles = Directory.GetFiles(sourceDirectory, "*.nnue");
        
        if (nnueFiles.Length == 0)
        {
            _outputSubject.OnNext("No neural network files found.");
            return false;
        }

        // Check if we have at least one valid (non-tiny) network file
        // The placeholder is only 1KB, real networks are several MB
        const long MinValidNetworkSize = 100_000; // 100KB minimum
        
        var validNetworks = nnueFiles.Where(f => new FileInfo(f).Length >= MinValidNetworkSize).ToArray();
        
        if (validNetworks.Length > 0)
        {
            _outputSubject.OnNext($"Valid network files for PGO: {string.Join(", ", validNetworks.Select(Path.GetFileName))}");
            return true;
        }
        else
        {
            _outputSubject.OnNext($"Network files present but too small (placeholders only): {string.Join(", ", nnueFiles.Select(Path.GetFileName))}");
            return false;
        }
    }

    private void CleanupTempDirectoryWithRetry(string? tempDirectory, string description = "temporary directory")
    {
        if (string.IsNullOrWhiteSpace(tempDirectory)) return;
        if (!Directory.Exists(tempDirectory)) return;
        const int maxRetries = 3;
        for (int attempt = 1; attempt <= maxRetries; attempt++)
        {
            try
            {
                Directory.Delete(tempDirectory, true);
                _outputSubject.OnNext($"Cleaned up {description}.");
                return;
            }
            catch (IOException) when (attempt < maxRetries)
            {
                Thread.Sleep(250 * attempt);
            }
            catch (UnauthorizedAccessException) when (attempt < maxRetries)
            {
                Thread.Sleep(250 * attempt);
            }
            catch (Exception ex)
            {
                _outputSubject.OnNext($"Warning: Could not delete {description} at {tempDirectory}: {ex.Message}");
                return;
            }
        }
        if (Directory.Exists(tempDirectory))
            _outputSubject.OnNext($"Warning: {description} persists: {tempDirectory}");
    }

    private bool BypassNetScriptIfNetworksPresent(string? rootDirectory)
    {
        if (string.IsNullOrWhiteSpace(rootDirectory))
            return false;

        var scriptPath = Path.Combine(rootDirectory, "scripts", "net.sh");
        if (!File.Exists(scriptPath))
            return false;

        var scriptContent = """
#!/bin/sh
echo "Networks already present; skipping net target."
exit 0
""";
        File.WriteAllText(scriptPath, scriptContent.Replace("\r\n", "\n"));
        return true;
    }

    private static int SanitizeParallelJobs(int jobs)
    {
        var max = Environment.ProcessorCount * 2;
        if (jobs < 1) return 1;
        if (jobs > max) return max;
        return jobs;
    }

    private static string SanitizeArchitecture(string? arch)
    {
        if (string.IsNullOrWhiteSpace(arch)) return Architectures.X86_64;
        
        var validArchs = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            Architectures.X86_64,
            Architectures.X86_64_VNNI512,
            Architectures.X86_64_VNNI256,
            Architectures.X86_64_AVX512,
            Architectures.X86_64_BMI2,
            Architectures.X86_64_AVX2,
            Architectures.X86_64_SSE41_POPCNT,
            Architectures.X86_64_SSSE3,
            Architectures.X86_64_SSE3_POPCNT,
            Architectures.ARMV8,
            Architectures.APPLE_SILICON
        };
        
        return validArchs.Contains(arch) ? arch : Architectures.X86_64;
    }

    private static string ValidateOutputPath(string outputDirectory, string filename)
    {
        if (string.IsNullOrWhiteSpace(outputDirectory)) 
            throw new SecurityException("Output directory not specified");

        var baseName = Path.GetFileName(filename);
        if (!string.Equals(baseName, filename, StringComparison.Ordinal)) 
            throw new SecurityException("Invalid output file name");
        if (baseName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) 
            throw new SecurityException("Invalid characters in output file name");

        var ext = Path.GetExtension(baseName);
        if (!string.IsNullOrEmpty(ext) && !ext.Equals(".exe", StringComparison.OrdinalIgnoreCase))
            throw new SecurityException("Disallowed file extension");

        var baseDir = new DirectoryInfo(Path.GetFullPath(outputDirectory));
        var systemDirs = new[]
        {
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            Environment.GetFolderPath(Environment.SpecialFolder.Windows),
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)
        };
        
        if (systemDirs.Any(d => !string.IsNullOrEmpty(d) && baseDir.FullName.StartsWith(d, StringComparison.OrdinalIgnoreCase)))
            throw new SecurityException("Refusing to write into system directory");

        Directory.CreateDirectory(baseDir.FullName);
        
        var fullPath = Path.GetFullPath(Path.Combine(baseDir.FullName, baseName));
        var targetFile = new FileInfo(fullPath);
        var targetDir = targetFile.DirectoryName;
        
        // Improved path traversal check using canonicalized paths
        if (targetDir == null || !string.Equals(targetDir, baseDir.FullName, StringComparison.OrdinalIgnoreCase))
            throw new SecurityException("Path traversal detected");
            
        return fullPath;
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        
        // Cancel any ongoing operations
        _cts?.Cancel();
        _cts?.Dispose();
        
        // Complete observables before disposing (prevents memory leaks)
        _outputSubject.OnCompleted();
        _progressSubject.OnCompleted();
        _isBuildingSubject.OnCompleted();
        
        // Now dispose the subjects
        _outputSubject.Dispose();
        _progressSubject.Dispose();
        _isBuildingSubject.Dispose();
    }
}

==== END FILE: Services\BuildService.cs ====

==== BEGIN FILE: Services\ICompilerService.cs (D:\GitHub\StockfishCompiler\Services\ICompilerService.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface ICompilerService
{
    /// <summary>
    /// Detects available C++ compilers on the system
    /// </summary>
    /// <returns>List of detected compiler information</returns>
    /// <remarks>
    /// Searches for compilers in the following locations:
    /// - MSYS2 installations (mingw64, ucrt64, clang64, etc.)
    /// - Git for Windows MinGW
    /// - Visual Studio Clang/LLVM and MSVC
    /// - Standalone MinGW installations
    /// - System PATH
    /// </remarks>
    Task<List<CompilerInfo>> DetectCompilersAsync();
    
    /// <summary>
    /// Validates that a compiler executable exists and is accessible
    /// </summary>
    /// <param name="compiler">The compiler information to validate</param>
    /// <returns>True if the compiler is valid and accessible, false otherwise</returns>
    Task<bool> ValidateCompilerAsync(CompilerInfo compiler);
    
    /// <summary>
    /// Gets the version information of a compiler
    /// </summary>
    /// <param name="compilerPath">Full path to the compiler executable</param>
    /// <returns>Version string from the compiler's --version output, or empty string if failed</returns>
    Task<string> GetCompilerVersionAsync(string compilerPath);
}

==== END FILE: Services\ICompilerService.cs ====

==== BEGIN FILE: Services\CompilerService.cs (D:\GitHub\StockfishCompiler\Services\CompilerService.cs) ====
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class CompilerService(ILogger<CompilerService> logger) : ICompilerService
{
    private static readonly string[] PathCandidates = ["g++", "clang++", "gcc", "clang"];

    public async Task<List<CompilerInfo>> DetectCompilersAsync()
    {
        logger.LogInformation("Starting comprehensive compiler detection");
        List<CompilerInfo> compilers = [];

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            compilers.AddRange(await DetectMSYS2CompilersAsync());
            compilers.AddRange(await DetectGitForWindowsCompilersAsync());
            compilers.AddRange(await DetectVisualStudioCompilersAsync());
            compilers.AddRange(await DetectMinGWStandaloneAsync());
            compilers.AddRange(await DetectPathCompilersAsync());
        }
        else
        {
            compilers.AddRange(await DetectUnixCompilersAsync());
        }

        logger.LogInformation("Total compilers found before deduplication: {Count}", compilers.Count);
        
        // Distinct by Path + Name
        var uniqueCompilers = compilers
            .GroupBy(c => c.Path + "|" + c.Name)
            .Select(g => g.First())
            .ToList();

        logger.LogInformation("Unique compilers after deduplication: {Count}", uniqueCompilers.Count);
        return uniqueCompilers;
    }

    public Task<bool> ValidateCompilerAsync(CompilerInfo compiler)
    {
        var exe = compiler.Name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ? compiler.Name : compiler.Name + ".exe";
        var fullPath = string.IsNullOrEmpty(compiler.Path) ? exe : Path.Combine(compiler.Path, exe);
        return Task.FromResult(File.Exists(fullPath));
    }

    public async Task<string> GetCompilerVersionAsync(string compilerPath)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = compilerPath,
                Arguments = "--version",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null)
                return string.Empty;

            var output = await process.StandardOutput.ReadToEndAsync();
            await process.WaitForExitAsync();
            var firstLine = output.Split('\n').FirstOrDefault()?.Trim() ?? string.Empty;
            return firstLine;
        }
        catch (Exception ex)
        {
            logger.LogDebug(ex, "Failed to get version for {Path}", compilerPath);
            return string.Empty;
        }
    }

    private async Task<List<CompilerInfo>> DetectMSYS2CompilersAsync()
    {
        logger.LogInformation("Searching for MSYS2 installations");
        
        // Wrap drive scanning in Task.Run to avoid UI freeze on network/sleeping drives
        var possiblePaths = await Task.Run(() =>
        {
            var paths = new List<string>();
            
            try
            {
                // Search common locations across all drives
                var drives = DriveInfo.GetDrives()
                    .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
                    .Select(d => d.Name.TrimEnd('\\'))
                    .ToList();

                logger.LogInformation("Searching drives: {Drives}", string.Join(", ", drives));

                foreach (var drive in drives)
                {
                    // Add root level msys2/msys64 paths
                    paths.Add(Path.Combine(drive, "msys64"));
                    paths.Add(Path.Combine(drive, "msys2"));
                    
                    // Check Program Files
                    paths.Add(Path.Combine(drive, "Program Files", "msys64"));
                    paths.Add(Path.Combine(drive, "Program Files", "msys2"));
                    
                    // Check tools directories
                    paths.Add(Path.Combine(drive, "tools", "msys64"));
                    paths.Add(Path.Combine(drive, "tools", "msys2"));
                }

                // Add user profile paths
                paths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys64"));
                paths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys2"));
                paths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "msys64"));
                paths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "msys2"));

                // Check environment variable
                var msysEnvVar = Environment.GetEnvironmentVariable("MSYS2_PATH");
                if (!string.IsNullOrEmpty(msysEnvVar))
                {
                    paths.Add(msysEnvVar);
                }
            }
            catch (Exception ex)
            {
                logger.LogWarning(ex, "Error scanning drives for MSYS2");
            }
            
            // Remove duplicates and check which paths exist
            return paths.Distinct(StringComparer.OrdinalIgnoreCase)
                       .Where(Directory.Exists)
                       .ToList();
        });

        List<CompilerInfo> compilers = [];
        
        foreach (var basePath in possiblePaths)
        {
            logger.LogInformation("Found MSYS2 at: {Path}", basePath);
            
            var msysPaths = new[]
            {
                Path.Combine(basePath, "mingw64", "bin"),
                Path.Combine(basePath, "mingw32", "bin"),
                Path.Combine(basePath, "ucrt64", "bin"),
                Path.Combine(basePath, "clang64", "bin"),
                Path.Combine(basePath, "clang32", "bin"),
                Path.Combine(basePath, "clangarm64", "bin")
            };

            foreach (var path in msysPaths.Where(Directory.Exists))
            {
                logger.LogDebug("Checking MSYS2 path: {Path}", path);
                
                var gcc = Path.Combine(path, "g++.exe");
                var clang = Path.Combine(path, "clang++.exe");

                if (File.Exists(gcc))
                {
                    logger.LogInformation("Found g++ at: {Path}", gcc);
                    var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                    compilerInfo.DisplayName = $"MSYS2 GCC - {Path.GetFileName(Path.GetDirectoryName(path))} ({basePath})";
                    compilers.Add(compilerInfo);
                }
                if (File.Exists(clang))
                {
                    logger.LogInformation("Found clang++ at: {Path}", clang);
                    var compilerInfo = await CreateCompilerInfoAsync(clang, "clang");
                    compilerInfo.DisplayName = $"MSYS2 Clang - {Path.GetFileName(Path.GetDirectoryName(path))} ({basePath})";
                    compilers.Add(compilerInfo);
                }
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectGitForWindowsCompilersAsync()
    {
        logger.LogInformation("Searching for Git for Windows");
        List<CompilerInfo> compilers = [];

        var gitPaths = new[]
        {
            @"C:\Program Files\Git\mingw64\bin",
            @"C:\Program Files (x86)\Git\mingw64\bin",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Programs", "Git", "mingw64", "bin")
        };

        foreach (var path in gitPaths.Where(Directory.Exists))
        {
            logger.LogInformation("Found Git for Windows at: {Path}", path);
            
            var gcc = Path.Combine(path, "g++.exe");
            if (File.Exists(gcc))
            {
                logger.LogInformation("Found g++ in Git: {Path}", gcc);
                var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                compilerInfo.DisplayName = $"Git for Windows GCC ({path})";
                compilers.Add(compilerInfo);
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectVisualStudioCompilersAsync()
    {
        logger.LogInformation("Searching for Visual Studio compilers");
        List<CompilerInfo> compilers = [];

        // Check for VS Build Tools and full VS installations
        var vsYears = new[] { "2022", "2019", "2017" };
        var vsEditions = new[] { "Community", "Professional", "Enterprise", "BuildTools", "Preview" };
        
        foreach (var year in vsYears)
        {
            foreach (var edition in vsEditions)
            {
                // Check for Clang/LLVM
                var clangPaths = new[]
                {
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\x64\bin",
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\bin",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\x64\bin",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\Llvm\bin"
                };

                foreach (var path in clangPaths.Where(Directory.Exists))
                {
                    logger.LogInformation("Found Visual Studio Clang at: {Path}", path);
                    
                    var clang = Path.Combine(path, "clang++.exe");
                    if (File.Exists(clang))
                    {
                        logger.LogInformation("Found clang++ in VS: {Path}", clang);
                        var compilerInfo = await CreateCompilerInfoAsync(clang, "clang");
                        compilerInfo.DisplayName = $"Visual Studio {year} {edition} - Clang/LLVM";
                        compilers.Add(compilerInfo);
                    }
                }

                // Check for MSVC (cl.exe)
                var msvcPaths = new[]
                {
                    $@"C:\Program Files\Microsoft Visual Studio\{year}\{edition}\VC\Tools\MSVC",
                    $@"C:\Program Files (x86)\Microsoft Visual Studio\{year}\{edition}\VC\Tools\MSVC"
                };

                foreach (var basePath in msvcPaths.Where(Directory.Exists))
                {
                    try
                    {
                        var msvcVersionDirs = Directory.GetDirectories(basePath);
                        foreach (var versionDir in msvcVersionDirs)
                        {
                            var clPath = Path.Combine(versionDir, "bin", "Hostx64", "x64", "cl.exe");
                            if (File.Exists(clPath))
                            {
                                logger.LogInformation("Found MSVC cl.exe at: {Path}", clPath);
                                var version = await GetMSVCVersionAsync(clPath);
                                var compilerInfo = new CompilerInfo
                                {
                                    Name = "cl.exe",
                                    Type = "msvc",
                                    Version = version,
                                    Path = Path.GetDirectoryName(clPath) ?? string.Empty,
                                    DisplayName = $"Visual Studio {year} {edition} - MSVC ({Path.GetFileName(versionDir)})",
                                    IsAvailable = true
                                };
                                compilers.Add(compilerInfo);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        logger.LogDebug(ex, "Error checking MSVC path: {Path}", basePath);
                    }
                }
            }
        }

        return compilers;
    }

    private async Task<string> GetMSVCVersionAsync(string clPath)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = clPath,
                Arguments = "",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null)
                return "Unknown version";

            var error = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();
            
            // MSVC outputs version info to stderr
            var firstLine = error.Split('\n').FirstOrDefault()?.Trim() ?? string.Empty;
            return firstLine.Length > 100 ? firstLine.Substring(0, 100) + "..." : firstLine;
        }
        catch (Exception ex)
        {
            logger.LogDebug(ex, "Failed to get MSVC version for {Path}", clPath);
            return "Unknown version";
        }
    }

    private async Task<List<CompilerInfo>> DetectMinGWStandaloneAsync()
    {
        logger.LogInformation("Searching for standalone MinGW");
        List<CompilerInfo> compilers = [];

        var mingwPaths = new List<string>
        {
            @"C:\MinGW\bin",
            @"C:\MinGW-w64\bin",
            @"C:\mingw64\bin",
            @"D:\MinGW\bin",
            @"D:\mingw64\bin",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "MinGW", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "MinGW", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "mingw64", "bin"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "mingw64", "bin")
        };

        // Check all drives for common MinGW locations
        var drives = DriveInfo.GetDrives()
            .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
            .Select(d => d.Name.TrimEnd('\\'));

        foreach (var drive in drives)
        {
            mingwPaths.Add(Path.Combine(drive, "MinGW", "bin"));
            mingwPaths.Add(Path.Combine(drive, "mingw64", "bin"));
            mingwPaths.Add(Path.Combine(drive, "MinGW-w64", "bin"));
        }

        foreach (var path in mingwPaths.Distinct().Where(Directory.Exists))
        {
            logger.LogInformation("Found MinGW at: {Path}", path);
            
            var gcc = Path.Combine(path, "g++.exe");
            if (File.Exists(gcc))
            {
                logger.LogInformation("Found g++ in MinGW: {Path}", gcc);
                var compilerInfo = await CreateCompilerInfoAsync(gcc, "gcc");
                compilerInfo.DisplayName = $"Standalone MinGW GCC ({path})";
                compilers.Add(compilerInfo);
            }
        }

        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectPathCompilersAsync()
    {
        logger.LogInformation("Searching for compilers in PATH");
        List<CompilerInfo> compilers = [];

        foreach (var c in PathCandidates)
        {
            var path = await WhichAsync(c);
            if (!string.IsNullOrEmpty(path))
            {
                logger.LogInformation("Found {Command} in PATH: {Path}", c, path);
                var type = c.Contains("clang") ? "clang" : "gcc";
                var compilerInfo = await CreateCompilerInfoAsync(path, type);
                compilerInfo.DisplayName = $"{type.ToUpper()} in PATH - {Path.GetDirectoryName(path)}";
                compilers.Add(compilerInfo);
            }
        }
        return compilers;
    }

    private async Task<List<CompilerInfo>> DetectUnixCompilersAsync()
    {
        logger.LogInformation("Searching for Unix compilers");
        List<CompilerInfo> compilers = [];
        
        foreach (var c in PathCandidates)
        {
            var path = await WhichAsync(c);
            if (!string.IsNullOrEmpty(path))
            {
                logger.LogInformation("Found {Command}: {Path}", c, path);
                var type = c.Contains("clang") ? "clang" : "gcc";
                compilers.Add(await CreateCompilerInfoAsync(path, type));
            }
        }
        return compilers;
    }

    private async Task<CompilerInfo> CreateCompilerInfoAsync(string compilerFullPath, string type)
    {
        var version = await GetCompilerVersionAsync(compilerFullPath);
        var shortVersion = version.Length > 50 ? version.Substring(0, 50) + "..." : version;
        
        return new CompilerInfo
        {
            Name = Path.GetFileName(compilerFullPath),
            Type = type,
            Version = shortVersion,
            Path = Path.GetDirectoryName(compilerFullPath) ?? string.Empty,
            DisplayName = $"{type.ToUpper()} - {Path.GetDirectoryName(compilerFullPath)}",
            IsAvailable = true
        };
    }

    private static readonly string[] LineSeparators = ["\r", "\n"];
    
    private static async Task<string> WhichAsync(string command)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "where" : "which",
                Arguments = command,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            if (process == null) return string.Empty;
            var output = await process.StandardOutput.ReadToEndAsync();
            await process.WaitForExitAsync();
            var first = output.Split(LineSeparators, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
            return first ?? string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }
}

==== END FILE: Services\CompilerService.cs ====

==== BEGIN FILE: Services\IStockfishDownloader.cs (D:\GitHub\StockfishCompiler\Services\IStockfishDownloader.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IStockfishDownloader
{
    Task<SourceDownloadResult> DownloadSourceAsync(string version, IProgress<string>? progress = null, CancellationToken cancellationToken = default);
    Task<bool> DownloadNeuralNetworkAsync(string sourceDirectory, BuildConfiguration? config = null, IProgress<string>? progress = null, CancellationToken cancellationToken = default);
    Task<ReleaseInfo?> GetLatestReleaseAsync(CancellationToken cancellationToken = default);
}

public class ReleaseInfo
{
    public string Version { get; set; } = string.Empty;
    public string Url { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
}

public class SourceDownloadResult
{
    public string SourceDirectory { get; set; } = string.Empty;
    public string RootDirectory { get; set; } = string.Empty;
    public string TempDirectory { get; set; } = string.Empty;
}

==== END FILE: Services\IStockfishDownloader.cs ====

==== BEGIN FILE: Services\StockfishDownloader.cs (D:\GitHub\StockfishCompiler\Services\StockfishDownloader.cs) ====
using System.IO;
using System.IO.Compression;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text.Json;
using System.Text.RegularExpressions;
using StockfishCompiler.Helpers;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class StockfishDownloader : IStockfishDownloader
{
    private readonly HttpClient _httpClient;
    private const string GitHubApiUrl = "https://api.github.com/repos/official-stockfish/Stockfish/releases/latest";
    private const string MasterZipUrl = "https://github.com/official-stockfish/Stockfish/archive/refs/heads/master.zip";
    private static readonly string[] NetworkMirrors =
    [
        "https://tests.stockfishchess.org/api/nn/{0}",
        "https://github.com/official-stockfish/networks/raw/master/{0}"
    ];
    private static readonly Regex NetworkMacroRegex = new("#define\\s+EvalFileDefaultName\\w*\\s+\"(nn-[a-z0-9]{12}\\.nnue)\"", RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromSeconds(1));
    private static readonly Regex NetworkFileNameRegex = new("nn-([a-f0-9]{12})\\.nnue", RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromSeconds(1));
    private const long MaxDownloadSize = 500L * 1024 * 1024; // 500 MB safety cap

    public StockfishDownloader(HttpClient httpClient)
    {
        _httpClient = httpClient;

        if (_httpClient.Timeout < TimeSpan.FromMinutes(5))
        {
            _httpClient.Timeout = TimeSpan.FromMinutes(10);
        }

        if (_httpClient.DefaultRequestHeaders.UserAgent.Count == 0)
        {
            _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("StockfishCompiler/1.0");
        }
    }

    public async Task<ReleaseInfo?> GetLatestReleaseAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            using var response = await _httpClient.GetAsync(GitHubApiUrl, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
            response.EnsureSuccessStatusCode();
            using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);
            using var doc = await JsonDocument.ParseAsync(stream, cancellationToken: cancellationToken);
            var root = doc.RootElement;
            return new ReleaseInfo
            {
                Version = root.GetProperty("tag_name").GetString() ?? "unknown",
                Url = root.GetProperty("zipball_url").GetString() ?? string.Empty,
                Name = root.GetProperty("name").GetString() ?? "Latest Release"
            };
        }
        catch
        {
            return null;
        }
    }

    public async Task<SourceDownloadResult> DownloadSourceAsync(string version, IProgress<string>? progress = null, CancellationToken cancellationToken = default)
    {
        progress?.Report($"Downloading Stockfish {version}...");

        var tempDir = Path.Combine(Path.GetTempPath(), $"stockfish_build_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempDir);

        var zipPath = Path.Combine(tempDir, "stockfish.zip");
        var url = version == "master" ? MasterZipUrl : (await GetLatestReleaseAsync(cancellationToken))?.Url ?? MasterZipUrl;

        await SafeDownloadToFileAsync(url, zipPath, progress, cancellationToken);

        progress?.Report("Extracting source code...");
        SafeExtractToDirectory(zipPath, tempDir);

        var extractedDirs = Directory.GetDirectories(tempDir).Where(d => d.Contains("Stockfish", StringComparison.OrdinalIgnoreCase)).ToArray();
        if (extractedDirs.Length == 0)
            throw new Exception("Could not find extracted Stockfish directory");

        var rootDir = extractedDirs[0];
        var sourceDir = Path.Combine(rootDir, "src");
        if (!Directory.Exists(sourceDir))
            throw new Exception($"Source directory not found: {sourceDir}");

        progress?.Report($"Source extracted to: {sourceDir}");
        return new SourceDownloadResult
        {
            SourceDirectory = sourceDir,
            RootDirectory = rootDir,
            TempDirectory = tempDir
        };
    }

    public async Task<bool> DownloadNeuralNetworkAsync(string sourceDirectory, BuildConfiguration? config = null, IProgress<string>? progress = null, CancellationToken cancellationToken = default)
    {
        progress?.Report("Preparing NNUE neural networks...");

        var networkFiles = DetectNetworkFileNames(sourceDirectory);
        if (networkFiles.Count == 0)
        {
            progress?.Report("Could not determine default network files - build will attempt to download them.");
            return false;
        }

        var overallSuccess = true;

        foreach (var networkFile in networkFiles)
        {
            var destination = Path.Combine(sourceDirectory, networkFile);
            if (File.Exists(destination))
            {
                if (await ValidateNetworkFileAsync(destination, networkFile, cancellationToken))
                {
                    progress?.Report($"{networkFile} already present and validated.");
                    continue;
                }

                progress?.Report($"{networkFile} exists but failed validation - re-downloading.");
            }

            var downloaded = false;
            foreach (var urlTemplate in NetworkMirrors)
            {
                var url = string.Format(urlTemplate, networkFile);
                try
                {
                    progress?.Report($"Downloading {networkFile} from {url}...");
                    
                    var tempNetPath = destination + ".tmp";
                    await SafeDownloadToFileAsync(url, tempNetPath, progress, cancellationToken);

                    if (!await ValidateNetworkFileAsync(tempNetPath, networkFile, cancellationToken))
                    {
                        progress?.Report($"Downloaded {networkFile} from {url} failed validation.");
                        File.Delete(tempNetPath);
                        continue;
                    }

                    var sizeMb = new FileInfo(tempNetPath).Length / 1024d / 1024d;
                    File.Move(tempNetPath, destination, true);
                    progress?.Report($"Saved {networkFile} ({sizeMb:F1} MB).");
                    downloaded = true;
                    break;
                }
                catch (Exception ex)
                {
                    progress?.Report($"Failed to download {networkFile} from {url} ({ex.Message}).");
                }
            }

            if (!downloaded)
            {
                overallSuccess = false;
                progress?.Report($"Unable to download {networkFile} - make will retry during build.");
            }
        }

        return overallSuccess;
    }

    private async Task SafeDownloadToFileAsync(string url, string destinationPath, IProgress<string>? progress, CancellationToken cancellationToken)
    {
        using var response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
        response.EnsureSuccessStatusCode();

        var totalBytes = response.Content.Headers.ContentLength ?? -1L;
        if (totalBytes > MaxDownloadSize)
            throw new InvalidOperationException($"Download too large: {totalBytes} bytes");

        using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);
        using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None, 8192, true);

        var buffer = new byte[8192];
        long totalRead = 0;
        int bytesRead;

        while ((bytesRead = await stream.ReadAsync(buffer, cancellationToken)) != 0)
        {
            await fileStream.WriteAsync(buffer.AsMemory(0, bytesRead), cancellationToken);
            totalRead += bytesRead;

            if (totalRead > MaxDownloadSize)
                throw new InvalidOperationException("Download exceeded maximum size");
        }
    }

    private static void SafeExtractToDirectory(string zipPath, string destinationDirectory)
    {
        using var archive = ZipFile.OpenRead(zipPath);
        var destDirFullPath = Path.GetFullPath(destinationDirectory);
        if (!Path.EndsInDirectorySeparator(destDirFullPath))
            destDirFullPath += Path.DirectorySeparatorChar;

        foreach (var entry in archive.Entries)
        {
            if (string.IsNullOrEmpty(entry.Name)) continue;

            var completeFileName = Path.GetFullPath(Path.Combine(destDirFullPath, entry.FullName));

            if (!completeFileName.StartsWith(destDirFullPath, StringComparison.OrdinalIgnoreCase))
            {
                throw new IOException("Zip Slip vulnerability detected: Entry tries to write outside target directory.");
            }

            var directory = Path.GetDirectoryName(completeFileName);
            if (!string.IsNullOrEmpty(directory))
                Directory.CreateDirectory(directory);

            entry.ExtractToFile(completeFileName, overwrite: true);
        }
    }

    private static List<string> DetectNetworkFileNames(string sourceDirectory)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var candidates = new[]
        {
            Path.Combine(sourceDirectory, "evaluate.h"),
            Path.Combine(sourceDirectory, "nnue", "evaluate.h")
        };

        foreach (var candidate in candidates)
        {
            if (!File.Exists(candidate))
                continue;

            var contents = File.ReadAllText(candidate);
            foreach (Match match in NetworkMacroRegex.Matches(contents))
            {
                if (match.Success)
                    names.Add(match.Groups[1].Value);
            }
        }

        return names.ToList();
    }

    private static async Task<bool> ValidateNetworkFileAsync(string filePath, string fileName, CancellationToken cancellationToken = default)
    {
        var info = new FileInfo(filePath);
        if (!info.Exists || info.Length < 1_000_000)
            return false;

        var match = NetworkFileNameRegex.Match(fileName);
        if (!match.Success)
            return true;

        var expectedPrefix = match.Groups[1].Value.ToLowerInvariant();

        using var sha256 = SHA256.Create();
        await using var stream = File.OpenRead(filePath);
        var hash = Convert.ToHexString(await sha256.ComputeHashAsync(stream, cancellationToken)).ToLowerInvariant();
        return hash.StartsWith(expectedPrefix, StringComparison.Ordinal);
    }

    private void EnsureUserAgent()
    {
        if (_httpClient.DefaultRequestHeaders.UserAgent.Count == 0)
            _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("StockfishCompiler/1.0");
    }
}

==== END FILE: Services\StockfishDownloader.cs ====

==== BEGIN FILE: Services\CompilerInstallerService.cs (D:\GitHub\StockfishCompiler\Services\CompilerInstallerService.cs) ====
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Security.Cryptography;
using System.Linq;
using System.Threading;
using System.Text.Json;
using Microsoft.Extensions.Logging;

namespace StockfishCompiler.Services;

public interface ICompilerInstallerService
{
    Task<(bool Installed, string? Path)> IsMSYS2InstalledAsync();
    Task<(bool Success, string InstallPath)> InstallMSYS2Async(IProgress<string>? progress = null, CancellationToken cancellationToken = default);
    Task<bool> InstallMSYS2PackagesAsync(string msys2Path, IProgress<string>? progress = null);
    Task<string> GetRecommendedInstallPathAsync();
}

public class CompilerInstallerService(ILogger<CompilerInstallerService> logger, HttpClient httpClient) : ICompilerInstallerService
{
    // Fallback to a known-good installer if latest lookup fails
    private const string FALLBACK_INSTALLER_URL = "https://github.com/msys2/msys2-installer/releases/download/2024-01-13/msys2-x86_64-20240113.exe";
    private const string FALLBACK_INSTALLER_SHA256 = "a24ca2f57c21c0f16d5d2e5e80f0ac94bdadad48f06cc11f06cb9e7526f18a66";
    private const string LATEST_API = "https://api.github.com/repos/msys2/msys2-installer/releases/latest";
    private const string DEFAULT_INSTALL_PATH = @"C:\msys64";
    
    public Task<(bool Installed, string? Path)> IsMSYS2InstalledAsync()
    {
        var candidates = new[]
        {
            @"C:\msys64",
            @"C:\msys2",
            @"D:\msys64",
            @"D:\msys2",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys64")
        };

        foreach (var path in candidates.Where(Directory.Exists))
        {
            var gxx = Path.Combine(path, "mingw64", "bin", "g++.exe");
            var make = Path.Combine(path, "usr", "bin", "make.exe");
            if (File.Exists(gxx) && File.Exists(make))
            {
                return Task.FromResult<(bool Installed, string? Path)>((true, path));
            }
        }

        return Task.FromResult<(bool Installed, string? Path)>((false, null));
    }

    public Task<string> GetRecommendedInstallPathAsync()
    {
        // Check which drive has more space
        var drives = DriveInfo.GetDrives()
            .Where(d => d.DriveType == DriveType.Fixed && d.IsReady)
            .OrderByDescending(d => d.AvailableFreeSpace)
            .ToList();

        foreach (var drive in drives)
        {
            var path = Path.Combine(drive.Name, "msys64");
            if (!Directory.Exists(path))
            {
                return Task.FromResult(path);
            }
        }

        return Task.FromResult(DEFAULT_INSTALL_PATH);
    }

    public async Task<(bool Success, string InstallPath)> InstallMSYS2Async(IProgress<string>? progress = null, CancellationToken cancellationToken = default)
    {
        try
        {
            progress?.Report("Checking for existing MSYS2 installation...");
            
            var (installed, existingPath) = await IsMSYS2InstalledAsync();
            
            if (installed && !string.IsNullOrWhiteSpace(existingPath))
            {
                logger.LogInformation("MSYS2 already installed at {Path}", existingPath);
                progress?.Report($"MSYS2 is already installed at {existingPath}.");
                return (true, existingPath);
            }

            var installPath = await GetRecommendedInstallPathAsync();
            progress?.Report($"Installing MSYS2 to {installPath}...");

            // Download the installer
            var tempPath = Path.Combine(Path.GetTempPath(), "msys2-installer.exe");
            
            progress?.Report("Resolving latest MSYS2 installer...");
            var (installerUrl, expectedHash) = await GetLatestInstallerAsync(cancellationToken);

            progress?.Report("Downloading MSYS2 installer...");
            logger.LogInformation("Downloading MSYS2 from {Url}", installerUrl);

            using (var response = await httpClient.GetAsync(installerUrl, HttpCompletionOption.ResponseHeadersRead, cancellationToken))
            {
                response.EnsureSuccessStatusCode();
                using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);
                using var fileStream = new FileStream(tempPath, FileMode.Create, FileAccess.Write, FileShare.None);
                
                await stream.CopyToAsync(fileStream, cancellationToken);
            }

            // Verify SHA256 checksum for security
            if (!string.IsNullOrWhiteSpace(expectedHash))
            {
                progress?.Report("Verifying installer integrity...");
                logger.LogInformation("Verifying SHA256 checksum of downloaded installer");
                
                if (!await VerifyFileHashAsync(tempPath, expectedHash))
                {
                    logger.LogError("MSYS2 installer hash mismatch! Expected: {Expected}", expectedHash);
                    progress?.Report("ERROR: Installer integrity check failed! The downloaded file may be corrupted or tampered with.");
                    
                    try { File.Delete(tempPath); } catch { }
                    return (false, string.Empty);
                }
                
                logger.LogInformation("Installer checksum verified successfully");
                progress?.Report("Installer verified. Starting installation...");
            }
            else
            {
                logger.LogWarning("Skipping checksum verification because no hash was available for the installer");
                progress?.Report("Installer downloaded (checksum unavailable). Proceeding with installation...");
            }

            // Run the installer silently
            var startInfo = new ProcessStartInfo
            {
                FileName = tempPath,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            startInfo.ArgumentList.Add("install");
            startInfo.ArgumentList.Add("--root");
            startInfo.ArgumentList.Add(installPath);
            startInfo.ArgumentList.Add("--confirm-command");

            using var process = Process.Start(startInfo);
            if (process == null)
            {
                logger.LogError("Failed to start MSYS2 installer");
                return (false, string.Empty);
            }

            // Add timeout to prevent indefinite hangs
            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(30));
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(timeoutCts.Token, cancellationToken);
            try
            {
                await process.WaitForExitAsync(linkedCts.Token);
            }
            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
            {
                logger.LogWarning("MSYS2 installation cancelled by user");
                progress?.Report("Installation cancelled.");
                try { process.Kill(true); } catch { }
                return (false, string.Empty);
            }
            catch (OperationCanceledException)
            {
                logger.LogError("MSYS2 installation timed out after 30 minutes");
                progress?.Report("Installation timed out. Please try installing MSYS2 manually.");
                try { process.Kill(true); } catch { }
                return (false, string.Empty);
            }

            if (process.ExitCode != 0)
            {
                logger.LogError("MSYS2 installation failed with exit code {ExitCode}", process.ExitCode);
                progress?.Report("Installation failed. Please try installing MSYS2 manually.");
                return (false, string.Empty);
            }

            // Clean up temp file
            try { File.Delete(tempPath); } catch { }

            progress?.Report("MSYS2 installed successfully!");
            
            // Install required packages
            progress?.Report("Installing C++ compilers...");
            await InstallMSYS2PackagesAsync(installPath, progress);

            return (true, installPath);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to install MSYS2");
            progress?.Report($"Installation error: {ex.Message}");
            return (false, string.Empty);
        }
    }

    private async Task<(string Url, string? Sha256)> GetLatestInstallerAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var response = await httpClient.GetAsync(LATEST_API, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
            response.EnsureSuccessStatusCode();
            await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);
            using var doc = await JsonDocument.ParseAsync(stream, cancellationToken: cancellationToken);

            if (!doc.RootElement.TryGetProperty("assets", out var assetsElement) || assetsElement.ValueKind != JsonValueKind.Array)
                return (FALLBACK_INSTALLER_URL, FALLBACK_INSTALLER_SHA256);

            var assets = assetsElement.EnumerateArray().ToArray();
            var installer = assets.FirstOrDefault(a =>
                a.TryGetProperty("name", out var nameProp) &&
                nameProp.GetString()?.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) == true &&
                nameProp.GetString()?.Contains("msys2-x86_64", StringComparison.OrdinalIgnoreCase) == true);

            if (installer.ValueKind == JsonValueKind.Undefined)
                return (FALLBACK_INSTALLER_URL, FALLBACK_INSTALLER_SHA256);

            var url = installer.GetProperty("browser_download_url").GetString() ?? FALLBACK_INSTALLER_URL;

            // Try to find a matching .sha256 asset to verify integrity
            string? hash = null;
            var installerName = installer.GetProperty("name").GetString();
            var hashAsset = assets.FirstOrDefault(a =>
                a.TryGetProperty("name", out var nameProp) &&
                nameProp.GetString()?.EndsWith(".sha256", StringComparison.OrdinalIgnoreCase) == true &&
                (installerName == null || nameProp.GetString()?.Contains(Path.GetFileNameWithoutExtension(installerName) ?? string.Empty, StringComparison.OrdinalIgnoreCase) == true));

            if (hashAsset.ValueKind != JsonValueKind.Undefined)
            {
                var hashUrl = hashAsset.GetProperty("browser_download_url").GetString();
                if (!string.IsNullOrEmpty(hashUrl))
                {
                    var hashContent = await httpClient.GetStringAsync(hashUrl, cancellationToken);
                    hash = ParseSha256FromFile(hashContent);
                }
            }

            return (url, string.IsNullOrWhiteSpace(hash) ? FALLBACK_INSTALLER_SHA256 : hash);
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Falling back to pinned MSYS2 installer");
            return (FALLBACK_INSTALLER_URL, FALLBACK_INSTALLER_SHA256);
        }
    }

    private static string? ParseSha256FromFile(string shaFileContents)
    {
        if (string.IsNullOrWhiteSpace(shaFileContents))
            return null;

        var firstLine = shaFileContents.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
        if (string.IsNullOrWhiteSpace(firstLine))
            return null;

        // Typical format: "<hash> *msys2-x86_64-YYYYMMDD.exe"
        var parts = firstLine.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var candidate = parts.Length > 0 ? parts[0] : null;
        if (candidate != null && candidate.Length == 64 && candidate.All(c => Uri.IsHexDigit(c)))
            return candidate.ToLowerInvariant();

        return null;
    }

    private static async Task<bool> VerifyFileHashAsync(string filePath, string expectedHash)
    {
        try
        {
            using var sha256 = SHA256.Create();
            using var stream = File.OpenRead(filePath);
            var hashBytes = await sha256.ComputeHashAsync(stream);
            var actualHash = Convert.ToHexString(hashBytes).ToLowerInvariant();
            var expected = expectedHash.ToLowerInvariant();
            
            return actualHash == expected;
        }
        catch (Exception)
        {
            return false;
        }
    }

    public async Task<bool> InstallMSYS2PackagesAsync(string msys2Path, IProgress<string>? progress = null)
    {
        try
        {
            // First, update the package database
            progress?.Report("Updating MSYS2 package database...");
            
            var bashPath = Path.Combine(msys2Path, "usr", "bin", "bash.exe");
            if (!File.Exists(bashPath))
            {
                logger.LogError("bash.exe not found at {Path}", bashPath);
                return false;
            }

            // Commands to run
            var commands = new[]
            {
                ("Updating core packages...", "-c \"pacman -Syu --noconfirm\""),
                ("Installing MinGW-w64 GCC compiler...", "-c \"pacman -S --noconfirm --needed mingw-w64-x86_64-gcc\""),
                ("Installing build tools...", "-c \"pacman -S --noconfirm --needed mingw-w64-x86_64-make mingw-w64-x86_64-toolchain\""),
                ("Installing Clang compiler (optional)...", "-c \"pacman -S --noconfirm --needed mingw-w64-clang-x86_64-clang\"")
            };

            foreach (var (message, command) in commands)
            {
                progress?.Report(message);
                
                var startInfo = new ProcessStartInfo
                {
                    FileName = bashPath,
                    Arguments = command,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    WorkingDirectory = msys2Path,
                    EnvironmentVariables =
                    {
                        ["MSYSTEM"] = "MINGW64",
                        ["PATH"] = $"{Path.Combine(msys2Path, "mingw64", "bin")};{Path.Combine(msys2Path, "usr", "bin")}"
                    }
                };

                using var process = Process.Start(startInfo);
                if (process == null) continue;

                // Add timeout for each package installation
                using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(15));
                try
                {
                    await process.WaitForExitAsync(cts.Token);
                }
                catch (OperationCanceledException)
                {
                    logger.LogWarning("Package installation command timed out: {Command}", command);
                    try { process.Kill(true); } catch { }
                    continue;
                }
                
                if (process.ExitCode != 0)
                {
                    logger.LogWarning("Package installation command failed: {Command}", command);
                    // Continue anyway, some packages might be optional
                }
            }

            progress?.Report("Compiler installation complete!");
            return true;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to install MSYS2 packages");
            progress?.Report($"Package installation error: {ex.Message}");
            return false;
        }
    }
}

==== END FILE: Services\CompilerInstallerService.cs ====

==== BEGIN FILE: Services\IUserSettingsService.cs (D:\GitHub\StockfishCompiler\Services\IUserSettingsService.cs) ====
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public interface IUserSettingsService
{
    UserSettings Load();
    void Save(UserSettings settings);
    string SettingsFilePath { get; }
}

==== END FILE: Services\IUserSettingsService.cs ====

==== BEGIN FILE: Services\UserSettingsService.cs (D:\GitHub\StockfishCompiler\Services\UserSettingsService.cs) ====
using System.IO;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using StockfishCompiler.Models;

namespace StockfishCompiler.Services;

public class UserSettingsService : IUserSettingsService
{
    private readonly ILogger<UserSettingsService> _logger;
    private readonly string _settingsPath;
    private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    public UserSettingsService(ILogger<UserSettingsService> logger)
    {
        _logger = logger;
        var appFolder = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "StockfishCompiler");
        Directory.CreateDirectory(appFolder);
        _settingsPath = Path.Combine(appFolder, "user-settings.json");
    }

    public string SettingsFilePath => _settingsPath;

    public UserSettings Load()
    {
        try
        {
            if (File.Exists(_settingsPath))
            {
                var json = File.ReadAllText(_settingsPath);
                try
                {
                    using var doc = JsonDocument.Parse(json);
                    if (doc.RootElement.ValueKind != JsonValueKind.Object)
                        throw new JsonException("Settings root must be an object");
                }
                catch (JsonException ex)
                {
                    _logger.LogWarning(ex, "Settings file corrupted, resetting to defaults");
                    File.Delete(_settingsPath);
                    var sanitizedDefaults = Sanitize(new UserSettings());
                    Save(sanitizedDefaults);
                    return sanitizedDefaults;
                }

                var settings = JsonSerializer.Deserialize<UserSettings>(json);
                if (settings != null)
                    return Sanitize(settings);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to load user settings; using defaults");
        }

        var defaults = Sanitize(new UserSettings());
        Save(defaults);
        return defaults;
    }

    public void Save(UserSettings settings)
    {
        try
        {
            var sanitized = Sanitize(settings);
            var json = JsonSerializer.Serialize(sanitized, _jsonOptions);
            File.WriteAllText(_settingsPath, json);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save user settings to {Path}", _settingsPath);
        }
    }

    private static UserSettings Sanitize(UserSettings settings)
    {
        settings.ParallelJobs = settings.ParallelJobs <= 0 ? Environment.ProcessorCount : settings.ParallelJobs;
        settings.OutputDirectory = string.IsNullOrWhiteSpace(settings.OutputDirectory)
            ? Environment.GetFolderPath(Environment.SpecialFolder.Desktop)
            : settings.OutputDirectory;
        settings.SourceVersion = string.IsNullOrWhiteSpace(settings.SourceVersion) ? "stable" : settings.SourceVersion;
        return settings;
    }
}

==== END FILE: Services\UserSettingsService.cs ====

==== BEGIN FILE: Helpers\MSYS2Helper.cs (D:\GitHub\StockfishCompiler\Helpers\MSYS2Helper.cs) ====
using System.IO;
using System.Runtime.InteropServices;
using StockfishCompiler.Models;

namespace StockfishCompiler.Helpers;

public static class MSYS2Helper
{
    public static string[] GetCommonMSYS2Paths() => new[]
    {
        @"C:\msys64",
        @"C:\msys2",
        @"D:\msys64",
        @"D:\msys2",
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "msys64")
    };

    public static string? FindMSYS2Installation()
    {
        return GetCommonMSYS2Paths().FirstOrDefault(IsValidMSYS2Installation);
    }

    public static string? FindMakeExecutable(string? compilerPath = null)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return "make";

        // Try to find make near the compiler
        if (!string.IsNullOrEmpty(compilerPath))
        {
            var compilerDir = new DirectoryInfo(compilerPath);
            var msys2Root = compilerDir.Parent?.Parent;
            
            if (msys2Root != null && msys2Root.Exists && IsValidMSYS2Installation(msys2Root.FullName))
            {
                var makePaths = new[]
                {
                    Path.Combine(msys2Root.FullName, "usr", "bin", "make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "make.exe"),
                    Path.Combine(msys2Root.FullName, "mingw64", "bin", "mingw32-make.exe")
                };

                foreach (var makePath in makePaths)
                {
                    if (File.Exists(makePath))
                        return makePath;
                }
            }
        }

        // Try common MSYS2 paths
        foreach (var msys2Path in GetCommonMSYS2Paths())
        {
            if (!Directory.Exists(msys2Path))
                continue;

            var makePaths = new[]
            {
                Path.Combine(msys2Path, "usr", "bin", "make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "make.exe"),
                Path.Combine(msys2Path, "mingw64", "bin", "mingw32-make.exe")
            };

            foreach (var makePath in makePaths)
            {
                if (File.Exists(makePath))
                    return makePath;
            }
        }

        return "make";
    }

    public static Dictionary<string, string> SetupEnvironment(BuildConfiguration? config = null)
    {
        var env = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        
        // Copy existing environment
        foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
        {
            if (entry.Key is string key && entry.Value is string value)
                env[key] = value;
        }

        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return env;

        var pathsToAdd = new List<string>();

        // Try compiler path first
        if (config?.SelectedCompiler?.Path != null)
        {
            var compilerDir = new DirectoryInfo(config.SelectedCompiler.Path);
            var msys2Root = compilerDir.Parent?.Parent;
            
            if (msys2Root != null && msys2Root.Exists && IsValidMSYS2Installation(msys2Root.FullName))
            {
                AddMSYS2PathsToList(msys2Root.FullName, pathsToAdd);
            }
        }

        // If no paths added, try common MSYS2 paths
        if (pathsToAdd.Count == 0)
        {
            var msys2Path = FindMSYS2Installation();
            if (msys2Path != null)
            {
                AddMSYS2PathsToList(msys2Path, pathsToAdd);
            }
        }

        // Update PATH if we found MSYS2 paths
        if (pathsToAdd.Count > 0)
        {
            var currentPath = env.GetValueOrDefault("PATH", string.Empty);
            env["PATH"] = string.Join(";", pathsToAdd) + ";" + currentPath;
        }

        return env;
    }

    private static void AddMSYS2PathsToList(string msys2Root, List<string> pathsToAdd)
    {
        var usrBin = Path.Combine(msys2Root, "usr", "bin");
        var mingw64Bin = Path.Combine(msys2Root, "mingw64", "bin");
        
        if (Directory.Exists(usrBin))
            pathsToAdd.Add(usrBin);
        if (Directory.Exists(mingw64Bin))
            pathsToAdd.Add(mingw64Bin);
    }

    public static bool IsValidMSYS2Installation(string path)
    {
        if (string.IsNullOrWhiteSpace(path) || !Directory.Exists(path))
            return false;

        var usrBin = Path.Combine(path, "usr", "bin");
        var makeExe = Path.Combine(usrBin, "make.exe");
        var mingw64 = Path.Combine(path, "mingw64");

        return Directory.Exists(usrBin) && Directory.Exists(mingw64) && File.Exists(makeExe);
    }
}

==== END FILE: Helpers\MSYS2Helper.cs ====

==== BEGIN FILE: Helpers\OSHelper.cs (D:\GitHub\StockfishCompiler\Helpers\OSHelper.cs) ====
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32;

namespace StockfishCompiler.Helpers;

public static class OSHelper
{
    public static string GetFriendlyOSName()
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            return GetWindowsVersionName();
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            return "Linux";
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            return "macOS";
        }
        
        return RuntimeInformation.OSDescription;
    }

    private static string GetWindowsVersionName()
    {
        var version = Environment.OSVersion.Version;
        var buildNumber = version.Build;

        try
        {
            var view = Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32;
            using var baseKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, view);
            using var key = baseKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
            if (key != null)
            {
                var productName = key.GetValue("ProductName")?.ToString();
                var displayVersion = key.GetValue("DisplayVersion")?.ToString();
                var releaseId = key.GetValue("ReleaseId")?.ToString();
                var rawBuild = key.GetValue("CurrentBuildNumber")?.ToString();

                if (int.TryParse(rawBuild, out var parsedBuild))
                {
                    buildNumber = parsedBuild;
                }

                if (!string.IsNullOrEmpty(productName))
                {
                    productName = productName.Replace("Microsoft ", "");

                    if (buildNumber >= 22000 && !productName.Contains("11"))
                    {
                        productName = "Windows 11";
                    }

                    var versionLabel = !string.IsNullOrEmpty(displayVersion)
                        ? displayVersion
                        : !string.IsNullOrEmpty(releaseId) ? releaseId : string.Empty;

                    if (string.IsNullOrWhiteSpace(versionLabel) && buildNumber > 0)
                    {
                        versionLabel = $"build {buildNumber}";
                    }

                    if (!string.IsNullOrWhiteSpace(versionLabel))
                    {
                        return $"{productName} {versionLabel}";
                    }
                    
                    return productName;
                }
            }
        }
        catch
        {
            // Fall back to basic detection
        }

        if (buildNumber >= 22000)
            return "Windows 11";

        if (version.Major == 10)
        {
            return "Windows 10";
        }
        else if (version.Major == 6)
        {
            if (version.Minor == 3)
                return "Windows 8.1";
            else if (version.Minor == 2)
                return "Windows 8";
            else if (version.Minor == 1)
                return "Windows 7";
        }

        return "Windows";
    }
}

==== END FILE: Helpers\OSHelper.cs ====

==== BEGIN FILE: Helpers\TextBoxHelper.cs (D:\GitHub\StockfishCompiler\Helpers\TextBoxHelper.cs) ====
using System.Windows;
using System.Windows.Controls;

namespace StockfishCompiler.Helpers;

public static class TextBoxHelper
{
    public static readonly DependencyProperty AlwaysScrollToEndProperty =
        DependencyProperty.RegisterAttached(
            "AlwaysScrollToEnd",
            typeof(bool),
            typeof(TextBoxHelper),
            new PropertyMetadata(false, OnAlwaysScrollToEndChanged));

    public static bool GetAlwaysScrollToEnd(DependencyObject obj)
    {
        return (bool)obj.GetValue(AlwaysScrollToEndProperty);
    }

    public static void SetAlwaysScrollToEnd(DependencyObject obj, bool value)
    {
        obj.SetValue(AlwaysScrollToEndProperty, value);
    }

    private static void OnAlwaysScrollToEndChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is TextBox textBox)
        {
            textBox.TextChanged -= TextBox_TextChanged;
            textBox.Loaded -= TextBox_Loaded;
            
            if ((bool)e.NewValue)
            {
                textBox.TextChanged += TextBox_TextChanged;
                textBox.Loaded += TextBox_Loaded;
                ScrollToEnd(textBox);
            }
        }
    }

    private static void TextBox_Loaded(object sender, RoutedEventArgs e)
    {
        if (sender is TextBox textBox)
        {
            ScrollToEnd(textBox);
        }
    }

    private static void TextBox_TextChanged(object sender, TextChangedEventArgs e)
    {
        if (sender is TextBox textBox)
        {
            ScrollToEnd(textBox);
        }
    }

    private static void ScrollToEnd(TextBox textBox)
    {
        textBox.CaretIndex = textBox.Text.Length;
        textBox.ScrollToEnd();
    }
}

==== END FILE: Helpers\TextBoxHelper.cs ====

==== BEGIN FILE: Converters\ValueConverters.cs (D:\GitHub\StockfishCompiler\Converters\ValueConverters.cs) ====
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace StockfishCompiler.Converters;

public class InverseBooleanConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
            return !boolValue;
        return true;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
            return !boolValue;
        return false;
    }
}

public class NullToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return value == null ? Visibility.Collapsed : Visibility.Visible;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

==== END FILE: Converters\ValueConverters.cs ====

==== BEGIN FILE: Resources\DarkTheme.xaml (D:\GitHub\StockfishCompiler\Resources\DarkTheme.xaml) ====
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:StockfishCompiler.Converters">
    <!-- Colors -->
    <Color x:Key="PrimaryColor">#2D3748</Color>
    <Color x:Key="SecondaryColor">#1A202C</Color>
    <Color x:Key="AccentColor">#4299E1</Color>
    <Color x:Key="SuccessColor">#48BB78</Color>
    <Color x:Key="WarningColor">#ED8936</Color>
    <Color x:Key="ErrorColor">#F56565</Color>

    <Color x:Key="TextPrimaryColor">#F7FAFC</Color>
    <Color x:Key="TextSecondaryColor">#A0AEC0</Color>
    <Color x:Key="BorderColor">#4A5568</Color>

    <!-- Brushes -->
    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="{StaticResource SecondaryColor}"/>
    <SolidColorBrush x:Key="AccentBrush" Color="{x:Static SystemParameters.WindowGlassColor}"/>
    <SolidColorBrush x:Key="SuccessBrush" Color="{StaticResource SuccessColor}"/>
    <SolidColorBrush x:Key="WarningBrush" Color="{StaticResource WarningColor}"/>
    <SolidColorBrush x:Key="ErrorBrush" Color="{StaticResource ErrorColor}"/>

    <SolidColorBrush x:Key="TextPrimaryBrush" Color="{StaticResource TextPrimaryColor}"/>
    <SolidColorBrush x:Key="TextSecondaryBrush" Color="{StaticResource TextSecondaryColor}"/>
    <SolidColorBrush x:Key="BorderBrush" Color="{StaticResource BorderColor}"/>
    <SolidColorBrush x:Key="BackgroundBrush" Color="{StaticResource SecondaryColor}"/>
    <SolidColorBrush x:Key="ForegroundBrush" Color="{StaticResource TextPrimaryColor}"/>
    <SolidColorBrush x:Key="ForegroundMutedBrush" Color="{StaticResource TextSecondaryColor}"/>

    <!-- Converters -->
    <local:InverseBooleanConverter x:Key="InverseBooleanConverter"/>
    <local:NullToVisibilityConverter x:Key="NullToVisibilityConverter"/>
    <BooleanToVisibilityConverter x:Key="BoolToVisibilityConverter"/>

    <!-- Control Styles -->
    <Style x:Key="DarkButton" TargetType="Button">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="15,8"/>
        <Setter Property="Margin" Value="5"/>
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Opacity" Value="0.5"/>
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style x:Key="DarkTabControl" TargetType="TabControl">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="0"/>
    </Style>

    <Style x:Key="DarkTabItem" TargetType="TabItem">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="TabItem">
                    <Border Name="Border" Background="{TemplateBinding Background}" 
                            BorderBrush="{TemplateBinding BorderBrush}" 
                            BorderThickness="1,1,1,0" 
                            CornerRadius="4,4,0,0" 
                            Margin="2,0,2,0" 
                            Padding="12,8">
                        <ContentPresenter x:Name="ContentSite" 
                                          VerticalAlignment="Center" 
                                          HorizontalAlignment="Center" 
                                          ContentSource="Header"/>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource SecondaryBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsSelected" Value="False">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource PrimaryBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter TargetName="Border" Property="Background" Value="{StaticResource AccentBrush}"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="DarkTextBox" TargetType="TextBox">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="8"/>
        <Setter Property="CaretBrush" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Improved ComboBox with dark dropdown -->
    <Style x:Key="DarkComboBox" TargetType="ComboBox">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="8,6"/>
        <Setter Property="ItemContainerStyle">
            <Setter.Value>
                <Style TargetType="ComboBoxItem">
                    <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
                    <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                    <Setter Property="Padding" Value="8,6"/>
                    <Style.Triggers>
                        <Trigger Property="IsHighlighted" Value="True">
                            <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
                            <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="ComboBox">
                    <Grid>
                        <ToggleButton x:Name="ToggleButton" 
                                      Background="{TemplateBinding Background}"
                                      BorderBrush="{TemplateBinding BorderBrush}"
                                      BorderThickness="{TemplateBinding BorderThickness}"
                                      Foreground="{TemplateBinding Foreground}"
                                      Focusable="False"
                                      IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                      ClickMode="Press">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition/>
                                    <ColumnDefinition Width="20"/>
                                </Grid.ColumnDefinitions>
                                <ContentPresenter Grid.Column="0" Margin="8,6" Content="{TemplateBinding SelectionBoxItem}" 
                                                  ContentTemplate="{TemplateBinding SelectionBoxItemTemplate}"
                                                  VerticalAlignment="Center" HorizontalAlignment="Left"/>
                                <Path Grid.Column="1" Data="M 0 0 L 4 4 L 8 0 Z" Fill="{StaticResource TextPrimaryBrush}" 
                                      VerticalAlignment="Center" HorizontalAlignment="Center"/>
                            </Grid>
                        </ToggleButton>
                        <Popup x:Name="Popup" Placement="Bottom" IsOpen="{TemplateBinding IsDropDownOpen}" 
                               AllowsTransparency="True" Focusable="False" PopupAnimation="Slide">
                            <Border Background="{StaticResource PrimaryBrush}" BorderBrush="{StaticResource BorderBrush}" 
                                    BorderThickness="1" SnapsToDevicePixels="True">
                                <ScrollViewer SnapsToDevicePixels="True">
                                    <StackPanel IsItemsHost="True" KeyboardNavigation.DirectionalNavigation="Contained"/>
                                </ScrollViewer>
                            </Border>
                        </Popup>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="DarkCheckBox" TargetType="CheckBox">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DarkRadioButton" TargetType="RadioButton">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DarkGroupBox" TargetType="GroupBox">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Margin" Value="0,10,0,0"/>
        <Setter Property="Padding" Value="10"/>
    </Style>

    <Style x:Key="InfoText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
    </Style>

    <Style x:Key="LabelText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        <Setter Property="Margin" Value="0,0,8,0"/>
    </Style>

    <Style x:Key="ValueText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style x:Key="DescriptionText" TargetType="TextBlock">
        <Setter Property="Foreground" Value="{StaticResource TextSecondaryBrush}"/>
        <Setter Property="TextWrapping" Value="Wrap"/>
    </Style>

    <Style x:Key="DarkProgressBar" TargetType="ProgressBar">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource AccentBrush}"/>
    </Style>

    <!-- StatusBar styling -->
    <Style TargetType="StatusBar">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <Style TargetType="StatusBarItem">
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Dark ScrollBar / ScrollViewer Styles -->
    <Style TargetType="ScrollViewer">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
    </Style>

    <!-- Thumb with rounded dark appearance -->
    <Style x:Key="DarkScrollBarThumb" TargetType="Thumb">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Thumb">
                    <Border Background="{TemplateBinding Background}" BorderBrush="{StaticResource BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" CornerRadius="4"/>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
            <Trigger Property="IsDragging" Value="True">
                <Setter Property="Background" Value="{StaticResource AccentBrush}"/>
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="ScrollBar">
        <Setter Property="Background" Value="{StaticResource SecondaryBrush}"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="ScrollBar">
                    <Grid Background="{TemplateBinding Background}">
                        <Track x:Name="PART_Track" Orientation="{TemplateBinding Orientation}" Focusable="False">
                            <Track.Thumb>
                                <Thumb Style="{StaticResource DarkScrollBarThumb}"/>
                            </Track.Thumb>
                        </Track>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="Orientation" Value="Horizontal">
                            <Setter TargetName="PART_Track" Property="IsDirectionReversed" Value="False"/>
                            <Setter TargetName="PART_Track" Property="Height" Value="10"/>
                        </Trigger>
                        <Trigger Property="Orientation" Value="Vertical">
                            <Setter TargetName="PART_Track" Property="IsDirectionReversed" Value="True"/>
                            <Setter TargetName="PART_Track" Property="Width" Value="10"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>

==== END FILE: Resources\DarkTheme.xaml ====

==== BEGIN FILE: README.md (D:\GitHub\StockfishCompiler\README.md) ====
# Stockfish Compiler

A WPF application for compiling Stockfish chess engine with automatic CPU architecture detection.

## Features

- Automatic compiler detection (MSYS2, MinGW, Clang)
- CPU architecture detection for optimal performance
- Download Stockfish source (latest stable release or master branch)
- Profile-guided optimization build
- Real-time build output and progress
- Dark-themed UI

## Requirements

- Windows 10/11 with .NET 8 Runtime
- MSYS2 with MinGW-w64 or Clang installed

## Installation

### Install MSYS2

1. Download and install MSYS2 from https://www.msys2.org/
2. Open MSYS2 MSYS terminal and run:
   ```bash
   pacman -Syu
   pacman -S mingw-w64-x86_64-gcc make
   ```

### Run StockfishCompiler

1. Extract the release to a folder
2. Run `StockfishCompiler.exe`

## Usage

1. **Compiler Setup Tab**
   - Click "Detect Compilers" to find installed compilers
   - Click "Detect Optimal Architecture" to auto-select best CPU architecture

2. **Build Configuration Tab**
   - Adjust parallel jobs (defaults to your CPU core count)
   - Set output directory where compiled Stockfish will be saved
   - Choose which Stockfish source to download (latest stable release or the master branch)
   - Choose build options (download network, strip executable)

3. **Compilation Tab**
   - Click "Start Build" to begin compilation
   - View real-time build output
   - Cancel build if needed

## Logs

Application logs are saved to:
```
%LOCALAPPDATA%\StockfishCompiler\logs\app-YYYY-MM-DD.log
```

You can open the logs folder directly from File Explorer by pasting the path above into the address bar.

## License

MIT License - see LICENSE file for details

## Credits

- Stockfish: https://github.com/official-stockfish/Stockfish
- UI Framework: WPF (.NET 8)
- MVVM Toolkit: CommunityToolkit.Mvvm
- Logging: Serilog

==== END FILE: README.md ====

==== BEGIN FILE: Export-FullContext.ps1 (D:\GitHub\StockfishCompiler\Export-FullContext.ps1) ====
param(
    [string]$Output = "full-context.txt"
)

# Explicit list of files to include (relative to repository root)
$files = @(
    "StockfishCompiler.csproj",
    "App.xaml",
    "App.xaml.cs",
    "MainWindow.xaml",
    "MainWindow.xaml.cs",
    "AssemblyInfo.cs",

    # Constants
    "Constants\CompilerConstants.cs",

    # Views
    "Views\BuildConfigurationView.xaml",
    "Views\BuildConfigurationView.xaml.cs",
    "Views\BuildProgressView.xaml",
    "Views\BuildProgressView.xaml.cs",
    "Views\CompilerSelectionView.xaml",
    "Views\CompilerSelectionView.xaml.cs",
    "Views\CompilerInstallerWindow.xaml",
    "Views\CompilerInstallerWindow.xaml.cs",

    # ViewModels
    "ViewModels\MainViewModel.cs",
    "ViewModels\BuildViewModel.cs",

    # Models
    "Models\ArchitectureInfo.cs",
    "Models\BuildConfiguration.cs",
    "Models\CompilationResult.cs",
    "Models\CompilerInfo.cs",
    "Models\UserSettings.cs",

    # Services
    "Services\IArchitectureDetector.cs",
    "Services\ArchitectureDetector.cs",
    "Services\IBuildService.cs",
    "Services\BuildService.cs",
    "Services\ICompilerService.cs",
    "Services\CompilerService.cs",
    "Services\IStockfishDownloader.cs",
    "Services\StockfishDownloader.cs",
    "Services\CompilerInstallerService.cs",
    "Services\IUserSettingsService.cs",
    "Services\UserSettingsService.cs",

    # Helpers
    "Helpers\MSYS2Helper.cs",
    "Helpers\OSHelper.cs",
    "Helpers\TextBoxHelper.cs",

    # Converters and Resources
    "Converters\ValueConverters.cs",
    "Resources\DarkTheme.xaml",

    # Scripts and docs helpful for context
    "README.md",
    "Export-FullContext.ps1"
)

# Create/overwrite output file
"" | Out-File -FilePath $Output -Encoding UTF8

foreach ($f in $files) {
    $fullPath = Join-Path -Path (Get-Location) -ChildPath $f
    $header = "==== BEGIN FILE: $f (" + $fullPath + ") ===="
    $footer = "==== END FILE: $f ===="

    Add-Content -Path $Output -Value $header

    if (Test-Path $fullPath) {
        Get-Content -Raw -Path $fullPath -Encoding UTF8 | Add-Content -Path $Output
    } else {
        Add-Content -Path $Output -Value "[MISSING FILE]"
    }

    Add-Content -Path $Output -Value $footer
    Add-Content -Path $Output -Value ""
}

Write-Host "Wrote full context to $Output"

==== END FILE: Export-FullContext.ps1 ====

